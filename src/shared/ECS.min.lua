--[[
	Roblox-ECS v1.2

	Roblox-ECS is a tiny and easy to use ECS (Entity Component System) engine for
	game development on the Roblox platform

	This is a minified version of Roblox-ECS, to see the full source code visit
	https://github.com/nidorx/roblox-ecs

	Discussions about this script are at https://devforum.roblox.com/t/841175

	This code was minified using https://goonlinetools.com/lua-minifier/

	------------------------------------------------------------------------------

	MIT License

	Copyright (c) 2020 Alex Rodin

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.
]]
local a=game:GetService('RunService')local function b()return DateTime.now().UnixTimestampMillis end;local c={}local d={}local function e(f)local g=c[f]if g~=nil then if g+1000<b()then print(d[f],' times > ',f)c[f]=b()d[f]=0;return end;d[f]=d[f]+1 else c[f]=b()d[f]=1 end end;local h=0.000000001;local function i(j,k)if j==k then return true end;return math.abs(k-j)<h end;local function l(m,n)if m==n then return true end;if not i(m.X,n.X)or not i(m.Y,n.Y)or not i(m.Z,n.Z)then return false else return true end end;local function o(p)if p==nil then p={}end;local q={}local r={}for s,t in pairs(p)do if t~=nil and q[t]==nil then table.insert(r,t)q[t]=true end end;table.sort(r)return r end;local function u(v)v=o(v)return'_'..table.concat(v,'_'),v end;local w={}local function x(y)local z={}if y==nil then y={}end;if y.requireAll==nil and y.requireAny==nil then error('It is necessary to define the components using the "requireAll" or "requireAny" parameters')end;if y.requireAll~=nil and y.requireAny~=nil then error('It is not allowed to use the "requireAll" and "requireAny" settings simultaneously')end;if y.requireAll~=nil then y.requireAllOriginal=y.requireAll;y.requireAll=o(y.requireAll)if table.getn(y.requireAll)==0 then error('You must enter at least one component id in the "requireAll" field')end elseif y.requireAny~=nil then y.requireAnyOriginal=y.requireAny;y.requireAny=o(y.requireAny)if table.getn(y.requireAny)==0 then error('You must enter at least one component id in the "requireAny" field')end end;if y.rejectAll~=nil and y.rejectAny~=nil then error('It is not allowed to use the "rejectAll" and "rejectAny" settings simultaneously')end;if y.rejectAll~=nil then y.rejectAll=o(y.rejectAll)if table.getn(y.rejectAll)==0 then error('You must enter at least one component id in the "rejectAll" field')end elseif y.rejectAny~=nil then y.rejectAny=o(y.rejectAny)if table.getn(y.rejectAny)==0 then error('You must enter at least one component id in the "rejectAny" field')end end;local A,B=u(y.requireAll)local C,D=u(y.requireAny)local E,F=u(y.rejectAll)local G,H=u(y.rejectAny)local I=y.requireAllOriginal;if I==nil then I=y.requireAnyOriginal end;return{components=I,match=function(I)local J=z[I]if J==false then return false elseif J==true then return true else local K=w[I]if K==nil then K={matchAny={},matchAll={},rejectAny={},rejectAll={}}w[I]=K end;if G~='_'then if K.rejectAny[G]or K.rejectAll[G]then z[I]=false;return false end;for s,t in pairs(H)do if table.find(I,t)then z[I]=false;K.matchAny[G]=true;K.rejectAny[G]=true;return false end end end;if E~='_'then if K.rejectAll[E]then z[I]=false;return false end;local L=true;for s,t in pairs(F)do if not table.find(I,t)then L=false;break end end;if L then z[I]=false;K.matchAll[E]=true;K.rejectAll[E]=true;return false end end;if C~='_'then if K.matchAny[C]or K.matchAll[C]then z[I]=true;return true end;for s,t in pairs(D)do if table.find(I,t)then K.matchAny[C]=true;z[I]=true;return true end end end;if A~='_'then if K.matchAll[A]then z[I]=true;return true end;local L=true;for s,t in pairs(B)do if not table.find(I,t)then L=false;break end end;if L then z[I]=true;K.matchAll[A]=true;K.rejectAll[A]=true;return true end end;z[I]=false;return false end end}end;local M=0;local N=1;local O={key=0,color=M}local function P(Q,R)local S=R.right;R.right=S.left;if S.left~=O then S.left.parent=R end;S.parent=R.parent;if R.parent==O then Q.root=S elseif R==R.parent.left then R.parent.left=S else R.parent.right=S end;S.left=R;R.parent=S end;local function T(Q,R)local U=R.left;R.left=U.right;if U.right~=O then U.right.parent=R end;U.parent=R.parent;if R.parent==O then Q.root=U elseif R==R.parent.right then R.parent.right=U else R.parent.left=U end;U.right=R;R.parent=U end;local function V(Q,R,W)if R.parent==O then Q.root=W elseif R==R.parent.left then R.parent.left=W else R.parent.right=W end;W.parent=R.parent end;local function X(R)while R.left~=O do R=R.left end;return R end;local function Y(R)if R==O then return nil end;if R.parent==R then return nil end;if R.right~=O then return X(R.right)end;local Z;while true do Z=R.parent;if Z==O then return nil end;if R==Z.right then R=Z else break end end;return Z end;local function _(Q,R)local Z=O;local a0=Q.root;while a0~=O do Z=a0;if R.key<a0.key then a0=a0.left else a0=a0.right end end;R.parent=Z;if Z==O then Q.root=R elseif R.key<Z.key then Z.left=R else Z.right=R end;R.left=O;R.right=O;R.color=N;while R.parent.color==N do if R.parent==R.parent.parent.left then Z=R.parent.parent.right;if Z.color==N then R.parent.color=M;Z.color=M;R.parent.parent.color=N;R=R.parent.parent else if R==R.parent.right then R=R.parent;P(Q,R)end;R.parent.color=M;R.parent.parent.color=N;T(Q,R.parent.parent)end else Z=R.parent.parent.left;if Z.color==N then R.parent.color=M;Z.color=M;R.parent.parent.color=N;R=R.parent.parent else if R==R.parent.left then R=R.parent;T(Q,R)end;R.parent.color=M;R.parent.parent.color=N;P(Q,R.parent.parent)end end end;Q.root.color=M end;local function a1(Q,R)if R==O then return end;local a2,a3;local a4=R.color;if R.left==O then a2=R.right;V(Q,R,R.right)elseif R.right==O then a2=R.left;V(Q,R,R.left)else local a5=X(R.right)a4=a5.color;a2=a5.right;if a5.parent==R then a2.parent=a5 else V(Q,a5,a5.right)a5.right=R.right;a5.right.parent=a5 end;V(Q,R,a5)a5.left=R.left;a5.left.parent=a5;a5.color=R.color end;if a4~=M then return end;while a2~=Q.root and a2.color==M do if a2==a2.parent.left then a3=a2.parent.right;if a3.color==N then a3.color=M;a2.parent.color=N;P(Q,a2.parent)a3=a2.parent.right end;if a3.left.color==M and a3.right.color==M then a3.color=N;a2=a2.parent else if a3.right.color==M then a3.left.color=M;a3.color=N;T(Q,a3)a3=a2.parent.right end;a3.color=a2.parent.color;a2.parent.color=M;a3.right.color=M;P(Q,a2.parent)a2=Q.root end else a3=a2.parent.left;if a3.color==N then a3.color=M;a2.parent.color=N;T(Q,a2.parent)a3=a2.parent.left end;if a3.right.color==M and a3.left.color==M then a3.color=N;a2=a2.parent else if a3.left.color==M then a3.right.color=M;a3.color=N;P(Q,a3)a3=a2.parent.left end;a3.color=a2.parent.color;a2.parent.color=M;a3.left.color=M;T(Q,a2.parent)a2=Q.root end end end;a2.color=M end;local function a6(Q,a7)local R=Q.root;while R~=O and a7~=R.key do if a7<R.key then R=R.left else R=R.right end end;return R end;local function a8(Q)if Q.root==O then return nil end;return X(Q.root)end;local function a9(Q,aa)local ab={}local R=a8(Q)while R~=nil do if aa(R)then table.insert(ab,R)end;R=Y(R)end;return ab end;local function ac(Q,ad)local R=a8(Q)while R~=nil do ad(R)R=Y(R)end end;local function ae(Q)local ab={}local R=a8(Q)while R~=nil do table.insert(ab,R)R=Y(R)end;return ab end;local function af()return{root=O,count=0}end;local function ag(a7,ah)return{key=a7,data=ah}end;local ai={}local aj=b()local ak={}ak.__index=ak;function ak.get(I)local al;al,I=u(I)if ai[al]==nil then ai[al]=setmetatable({id=al,components=I},ak)aj=b()end;return ai[al]end;function ak:with(am)if table.find(self.components,am)~=nil then return self end;local an=table.getn(self.components)local ao=table.create(an+1)ao[0]=am;table.move(self.components,1,an,2,ao)return ak.get(ao)end;function ak:without(am)if table.find(self.components,am)==nil then return self end;local an=table.getn(self.components)local ao=table.create(an-1)local ap=1;for aq=1,an do if self.components[aq]~=am then ao[ap]=self.components[aq]ap=ap+1 end end;return ak.get(ao)end;function ak:has(am)return table.find(self.components,am)~=nil end;local ar=ak.get({})local as={}local at={}local au={}local av={}local function aw(ax)return ax end;local ay={register=function(az,aA,aB)if az==nil then error('Component name is required for registration')end;if aA~=nil and type(aA)~='function'then error('The component constructor must be a function, or nil')end;if aA==nil then aA=aw end;if aB==nil then aB=false end;if av[az]~=nil then error('Another component already registered with that name')end;local aC=table.getn(as)+1;av[az]=aC;table.insert(as,az)table.insert(au,aB)table.insert(at,aA)return aC end}local aD=ay.register('_ECS_ENTITY_ID_')local aE={}aE.__index=aE;local aF=100;function aE.new(aG,aH)local aI={}aI[aD]=table.create(aF)for s,aJ in pairs(aH.components)do if au[aJ]then aI[aJ]=nil else aI[aJ]=table.create(aF)end end;return setmetatable({version=0,count=0,world=aG,archetype=aH,buffers=aI},aE)end;function aE:clear(aK)local aI=self.buffers;for aL in pairs(aI)do aI[aL][aK]=nil end end;function aE:getValue(aK,am)local aI=self.buffers;if aI[am]==nil then return nil end;return aI[am][aK]end;function aE:setValue(aK,am,ax)local aI=self.buffers;if aI[am]==nil then return end;aI[am][aK]=ax end;function aE:get(aK)local ah={}local aI=self.buffers;for am in pairs(aI)do ah[am]=aI[am][aK]end;return ah end;function aE:set(aK,ah)local aI=self.buffers;for am,ax in pairs(ah)do if aI[am]~=nil then aI[am][aK]=ax end end end;function aE:setEntityId(aK,aM)self.buffers[aD][aK]=aM end;local aN={}aN.__index=aN;function aN.new(aG)return setmetatable({world=aG,version=0,COUNT=0,ENTITIES={},ARCHETYPES={}},aN)end;function aN:set(aO,aH)local aP=aH.id;local aM=self.ENTITIES[aO]local aQ=nil;if aM~=nil then if aM.archetype==aP then return end;aQ=self.ARCHETYPES[aM.archetype].chunks[aM.chunk]:get(aM.chunkIndex)self:remove(aO)end;if self.ARCHETYPES[aP]==nil then self.ARCHETYPES[aP]={count=0,lastChunk=1,nextChunkIndex=1,chunks={aE.new(self.world,aH)}}self.version=self.version+1 end;local aR=self.ARCHETYPES[aP]self.ENTITIES[aO]={archetype=aP,chunk=aR.lastChunk,chunkIndex=aR.nextChunkIndex}self.COUNT=self.COUNT+1;local aS=aR.chunks[aR.lastChunk]aS:clear(aR.nextChunkIndex)if aQ~=nil then aS:set(aR.nextChunkIndex,aQ)end;aS:setEntityId(aR.nextChunkIndex,aO)aR.count=aR.count+1;aS.count=aR.nextChunkIndex;aR.nextChunkIndex=aR.nextChunkIndex+1;aS.version=self.world.version;if aR.nextChunkIndex>aF then aR.lastChunk=aR.lastChunk+1;aR.nextChunkIndex=1;aR.chunks[aR.lastChunk]=aE.new(self.world,aH)self.version=self.version+1 end end;function aN:remove(aO)local aM=self.ENTITIES[aO]if aM==nil then return end;local aR=self.ARCHETYPES[aM.archetype]local aS=aR.chunks[aM.chunk]aS:clear(aM.chunkIndex)aS.count=aS.count-1;self.ENTITIES[aO]=nil;self.COUNT=self.COUNT-1;aR.count=aR.count-1;if aR.nextChunkIndex==1 then aR.chunks[aR.lastChunk]=nil;aR.lastChunk=aR.lastChunk-1;aR.nextChunkIndex=aF+1;self.version=self.version+1 end;if aR.count>0 then if aR.nextChunkIndex>1 then if not(aR.lastChunk==aM.chunk and aR.nextChunkIndex-1==aM.chunkIndex)then local aT=aR.chunks[aR.lastChunk]:get(aR.nextChunkIndex-1)aR.chunks[aM.chunk]:set(aM.chunkIndex,aT)local aU=aT[aD]local aV=self.ENTITIES[aU]aV.chunk=aM.chunk;aV.chunkIndex=aM.chunkIndex end;aR.nextChunkIndex=aR.nextChunkIndex-1;aR.chunks[aR.lastChunk]:clear(aR.nextChunkIndex)end else aR.nextChunkIndex=aR.nextChunkIndex-1 end end;function aN:count()return self.COUNT end;function aN:clear(aO)local aM=self.ENTITIES[aO]if aM==nil then return end;local aS=self.ARCHETYPES[aM.archetype].chunks[aM.chunk]aS:clear(aM.chunkIndex)end;function aN:getValue(aO,am)local aM=self.ENTITIES[aO]if aM==nil then return nil end;return self.ARCHETYPES[aM.archetype].chunks[aM.chunk]:getValue(aM.chunkIndex,am)end;function aN:setValue(aO,am,ax)local aM=self.ENTITIES[aO]if aM==nil then return end;local aS=self.ARCHETYPES[aM.archetype].chunks[aM.chunk]aS:setValue(aM.chunkIndex,am,ax)end;function aN:getData(aO)local aM=self.ENTITIES[aO]if aM==nil then return nil end;local aS=self.ARCHETYPES[aM.archetype].chunks[aM.chunk]return aS:get(aM.chunkIndex)end;function aN:setData(aO,am,ah)local aM=self.ENTITIES[aO]if aM==nil then return end;local aS=self.ARCHETYPES[aM.archetype].chunks[aM.chunk]aS:set(aM.chunkIndex,am,ah)end;function aN:getEntityChunk(aO)local aM=self.ENTITIES[aO]if aM==nil then return end;return self.ARCHETYPES[aM.archetype].chunks[aM.chunk],aM.chunkIndex end;function aN:filterChunks(aW)local aX={}for aP,aR in pairs(self.ARCHETYPES)do if aW(ai[aP].components)then for aq,aS in pairs(aR.chunks)do table.insert(aX,aS)end end end;return aX end;local aY={}local aZ={}local a_={}function a_.register(y)if y==nil then error('System configuration is required for its creation')end;if y.name==nil then error('The system "name" is required for registration')end;if aZ[y.name]~=nil then error('Another System already registered with that name')end;local b0=x(y)if y.step==nil then y.step='transform'end;if y.step~='task'and y.step~='render'and y.step~='process'and y.step~='processIn'and y.step~='processOut'and y.step~='transform'then error('The "step" parameter must be "task", "render", "process", "transform", "processIn" or "processOut"')end;if y.step=='task'then if y.order~=nil then error('Task-type systems do not accept the "order" parameter')end;if y.update~=nil then error('Task-type systems do not accept the "update" parameter')end;if y.beforeUpdate~=nil then error('Task-type systems do not accept the "beforeUpdate" parameter')end;if y.onEnter~=nil then error('Task-type systems do not accept the "onEnter" parameter')end;if y.execute==nil then error('The task "execute" method is required for registration')end end;if y.order==nil or y.order<0 then y.order=50 end;table.insert(aY,{name=y.name,filter=b0,requireAll=y.requireAll,requireAny=y.requireAny,requireAllOriginal=y.requireAllOriginal,requireAnyOriginal=y.requireAnyOriginal,rejectAll=y.rejectAll,rejectAny=y.rejectAny,beforeUpdate=y.beforeUpdate,update=y.update,onEnter=y.onEnter,onRemove=y.onRemove,beforeExecute=y.beforeExecute,execute=y.execute,step=y.step,order=y.order})local aC=table.getn(aY)aZ[y.name]=aC;return aC end;local b1={}b1.__index=b1;local b2=0.008;local b3=0.002;function b1.new(aG,b4)return setmetatable({world=aG,entityManager=b4,min_vruntime=0,rbtree=af(),lastEntityManagerVersion=-1,systems={}},b1)end;function b1:addSystem(b5,y)if self.systems[b5]~=nil then return end;if y==nil then y={}end;local b6={id=b5,name=aY[b5].name,requireAll=aY[b5].requireAll,requireAny=aY[b5].requireAny,requireAllOriginal=aY[b5].requireAllOriginal,requireAnyOriginal=aY[b5].requireAnyOriginal,rejectAll=aY[b5].rejectAll,rejectAny=aY[b5].rejectAny,filter=aY[b5].filter,beforeExecute=aY[b5].beforeExecute,execute=aY[b5].execute,config=y}self.systems[b5]=b6;self.lastEntityManagerVersion=0 end;function b1:run(b7)if self.entityManager.version~=self.lastEntityManagerVersion then self:update()self.lastEntityManagerVersion=self.entityManager.version end;local Q=self.rbtree;local aG=self.world;local b8=math.max(b2,0.01667-(os.clock()-b7.frameReal)-b3)local b9={}local ba=os.clock()local bb,aS,b6,bc,bd;local be=a8(Q)while be~=nil do a1(Q,be)aS=be.data[1]b6=be.data[2]bc=be.data[3]bd=be.data[4]bb=os.clock()if bd==0 then bd=bb end;local bf=b6.requireAllOriginal;if bf==nil then bf=b6.requireAnyOriginal end;local bg=table.getn(bf)local bh=b6.execute;aG.version=aG.version+1;if b6.beforeExecute~=nil then b6.beforeExecute(b7,aG,b6)end;local bi=aS.version==0 or aS.version>bc;local aI=aS.buffers;local bj=aI[aD]local bk=table.create(bg)local bl=false;for bm,bn in ipairs(bf)do if aI[bn]~=nil then bk[bm]=aI[bn]else bk[bm]={}end end;local bo={process=b7.process,frame=b7.frame,frameReal=b7.frameReal,delta=b7.delta,deltaExec=bb-bd}for aK=1,aS.count do if bh(bo,aG,bi,bj[aK],aK,table.unpack(bk))then bl=true end end;if bl then aS.version=aG.version end;be.data[3]=aG.version;be.data[4]=bb;be.key=be.key+os.clock()-bb;_(Q,be)if os.clock()-ba>b8 then break end;be=Y(be)end;local bp=a8(Q)if bp~=nil then self.min_vruntime=math.max(bp.key-h,0)else self.min_vruntime=0 end end;function b1:update()local Q=self.rbtree;local bq=self.systems;local b4=self.entityManager;local br=self.min_vruntime;local bs=self.world.version;local bt={}local bu={}local aS,b6;ac(Q,function(be)aS=be.data[1]b6=be.data[2]if bt[aS]==nil then bt[aS]={}end;if bt[aS][b6]==nil then bt[aS][b6]={}end;table.insert(bt[aS][b6],be)bu[aS]=true end)for aq,bv in pairs(bq)do local aX=b4:filterChunks(bv.filter.match)for bw,bx in pairs(aX)do bu[bx]=nil;if bt[bx]==nil then _(Q,ag(br,{bx,bv,bs,0}))elseif bt[bx][bv]==nil then _(Q,ag(br,{bx,bv,bs,0}))end end end;for by,s in pairs(bu)do for bz,b9 in pairs(bt[by])do for s,be in ipairs(b9)do a1(Q,be)end end end end;local function bA(aG,bq)local bB={processIn={},process={},processOut={},transform={},render={}}local bC={}local bD={}for aL,b6 in pairs(bq)do if b6.update~=nil then if bB[b6.step][b6.order]==nil then bB[b6.step][b6.order]={}end;table.insert(bB[b6.step][b6.order],b6)end;if b6.onEnter~=nil then table.insert(bC,b6)end;if b6.onRemove~=nil then table.insert(bD,b6)end end;local bE=function(bF,b4,b7,bG)for aq,bH in pairs(bB[bF])do for bw,b6 in pairs(bH)do b6.lastUpdate=b7;local bf=b6.requireAllOriginal;if bf==nil then bf=b6.requireAnyOriginal end;local bg=table.getn(bf)local bI=b6.version;local aX=b4:filterChunks(b6.filter.match)local bJ=b6.update;aG.version=aG.version+1;if b6.beforeUpdate~=nil then b6.beforeUpdate(b7,bG,aG,b6)end;for aL,aS in pairs(aX)do local bi=aS.version==0 or aS.version>bI;local aI=aS.buffers;local bj=aI[aD]local bk=table.create(bg)local bl=false;for bm,bn in ipairs(bf)do if aI[bn]~=nil then bk[bm]=aI[bn]else bk[bm]={}end end;for aK=1,aS.count do if bJ(b7,aG,bi,bj[aK],aK,table.unpack(bk))then bl=true end end;if bl then aS.version=aG.version end end;b6.version=aG.version end end end;local bK=function(bL,b4,b7)aG.version=aG.version+1;for aO,bM in pairs(bL)do local bN=x({requireAny=bM})local aS,aK=b4:getEntityChunk(aO)if aS~=nil then local aI=aS.buffers;for bw,b6 in pairs(bC)do if b6.filter.match(aS.archetype.components)then local bf=b6.requireAllOriginal;if bf==nil then bf=b6.requireAnyOriginal end;if bN.match(bf)then local bk=table.create(table.getn(bf))for bm,bn in ipairs(bf)do if aI[bn]~=nil then bk[bm]=aI[bn]else bk[bm]={}end end;if b6.onEnter(b7,aG,aO,aK,table.unpack(bk))then aS.version=aG.version end end end end end end end;local bO=function(bP,b4,b7)aG.version=aG.version+1;for aO,s in pairs(bP)do local aS,aK=b4:getEntityChunk(aO)if aS~=nil then local aI=aS.buffers;for s,b6 in pairs(bD)do if b6.filter.match(aS.archetype.components)then local bf=b6.requireAllOriginal;if bf==nil then bf=b6.requireAnyOriginal end;local bk=table.create(table.getn(bf))for bm,bn in ipairs(bf)do if aI[bn]~=nil then bk[bm]=aI[bn]else bk[bm]={}end end;if b6.onRemove(b7,aG,aO,aK,table.unpack(bk))then aS.version=aG.version end end end end end end;return bE,bK,bO end;local bQ={Component=ay,System=a_,Filter=x}function bQ.newWorld(bq,y)if y==nil then y={}end;if y.frequency==nil then y.frequency=30 end;local bR=math.round(math.abs(y.frequency)/2)*2;if bR<2 then bR=2 end;if y.frequency~=bR then y.frequency=bR;print(string.format(">>> ATTENTION! The execution frequency of world has been changed to %d <<<",bR))end;local bS=1;local bT={}local bU;local bV,bW,bX;local bY=1000/y.frequency/1000;local bG=1;local bZ=nil;local b_=0;local c0=0;local c1=0;local c2=0;local c3=0;local c4=0;local c5=10;local c6=0;local b4;local c7;local c8;local c9={}local ca={}local cb={}local cc={}local aG;local cd;local ce=false;aG={version=0,frequency=y.frequency,create=function()local aC=bS;bS=bS+1;c7:set(aC,ar)c9[aC]=true;cc[aC]=ar;ce=true;return aC end,get=function(aM,am)if c9[aM]==true then return c7:getValue(aM,am)elseif cb[aM]~=nil then return c8:getValue(aM,am)else return b4:getValue(aM,am)end end,set=function(aM,am,...)local aH=cc[aM]if aH==nil then return end;ce=true;local cf=aH:with(am)local cg=aH~=cf;if cg then cc[aM]=cf end;local ax=at[am](table.unpack({...}))if c9[aM]==true then if cg then c7:set(aM,cf)end;c7:setValue(aM,am,ax)else if cg then if cb[aM]==nil then cb[aM]={received={},lost={}}c8:set(aM,cf)c8:setData(aM,b4:getData(aM))else c8:set(aM,cf)end end;if cb[aM]~=nil then c8:setValue(aM,am,ax)local ch=false;for aL,t in pairs(cb[aM].lost)do if t==am then table.remove(cb[aM].lost,aL)ch=true;break end end;if not ch then table.insert(cb[aM].received,am)end end;b4:setValue(aM,am,ax)end end,remove=function(aM,am)local aH=cc[aM]if aH==nil then return end;if ca[aM]==true then return end;ce=true;if am==nil then if c9[aM]==true then c7:remove(aM)c9[aM]=nil;cc[aM]=nil else if ca[aM]==nil then ca[aM]=true end end else local cf=aH:without(am)local cg=aH~=cf;if cg then cc[aM]=cf end;if c9[aM]==true then if cg then c7:set(aM,cf)end else if cg then if cb[aM]==nil then cb[aM]={received={},lost={}}c8:set(aM,cf)c8:setData(aM,b4:getData(aM))else c8:set(aM,cf)end end;if cb[aM]~=nil then c8:setValue(aM,am,nil)local ch=false;for aL,t in pairs(cb[aM].received)do if t==am then table.remove(cb[aM].received,aL)ch=true;break end end;if not ch then table.insert(cb[aM].lost,am)end end;b4:setValue(aM,am,nil)end end end,has=function(aM,am)if cc[aM]==nil then return false end;return cc[aM]:has(am)end,forEach=function(b0,ad)local ci=false;local cj=function()ci=true end;local aX=b4:filterChunks(b0.match)for aL,aS in pairs(aX)do local aI=aS.buffers;local bk=table.create(table.getn(b0.components))for bm,bn in ipairs(b0.components)do if aI[bn]~=nil then bk[bm]=aI[bn]else bk[bm]={}end end;local bj=aI[aD]local bl=false;for aK=1,aS.count do if ad(cj,bj[aK],aK,table.unpack(bk))then bl=true end;if ci then break end end;if bl then aS.version=aG.version end;if ci then break end end end,addSystem=function(b5,ck,y)if b5==nil then return end;if aY[b5]==nil then error('There is no registered system with the given ID')end;if aY[b5].step=='task'then bU:addSystem(b5)else if bT[b5]~=nil then return end;if b4:count()>0 or c7:count()>0 then error('Adding systems is not allowed after adding entities in the world')end;if y==nil then y={}end;local b6={id=b5,name=aY[b5].name,requireAll=aY[b5].requireAll,requireAny=aY[b5].requireAny,requireAllOriginal=aY[b5].requireAllOriginal,requireAnyOriginal=aY[b5].requireAnyOriginal,rejectAll=aY[b5].rejectAll,rejectAny=aY[b5].rejectAny,filter=aY[b5].filter,beforeUpdate=aY[b5].beforeUpdate,update=aY[b5].update,onEnter=aY[b5].onEnter,onRemove=aY[b5].onRemove,step=aY[b5].step,order=aY[b5].order,version=0,lastUpdate=c2,config=y}if ck~=nil and ck<0 then b6.order=50 end;bT[b5]=b6;c6=0 end end,alive=function(aM)if cc[aM]==nil then return false end;if c9[aM]==true then return false end;if ca[aM]==true then return false end;return true end,destroy=function()if aG._steppedConn~=nil then aG._steppedConn:Disconnect()aG._steppedConn=nil end;if aG._heartbeatConn~=nil then aG._heartbeatConn:Disconnect()aG._heartbeatConn=nil end;if aG._renderSteppedConn~=nil then aG._renderSteppedConn:Disconnect()aG._renderSteppedConn=nil end;b4=nil;c7=nil;c8=nil;cb=nil;ca=nil;bT=nil;bV=nil;bW=nil;bX=nil;cd=nil;cc=nil;bU=nil;aG.create=nil;aG.set=nil;aG.get=nil;aG.remove=nil;aG.has=nil;aG.forEach=nil;aG.addSystem=nil;aG.alive=nil;aG.update=nil;aG.destroy=nil;aG=nil end,update=function(bF,cl)if not a:IsRunning()then return end;if bZ==nil then bZ=cl end;local cm=cl;cl=cl-bZ;if c6<aj then bV,bW,bX=bA(aG,bT)c6=aj end;if bF~='process'then if c2~=c3 then bG=1+(cl-c2)/bY else bG=1 end;if bF=='processIn'then c0=cl;c1=cm;if b_==0 then b_=c0 end;if c2==0 then c2=c0;c3=c0 end;c4=c0-b_;bG=1 elseif bF=='render'then b_=c0 end;local b7={process=c2,frame=c0,frameReal=c1,now=cl,nowReal=cm,delta=c4}bV(bF,b4,b7,bG)while ce do cd(b7)end;if bF=='transform'then bU:run(b7)end else local cn=c2;local co=0;local cp=false;while c2<c0 and co<c5 do cp=true;if c6<aj then bV,bW=bA(aG,bT)c6=aj end;local b7={process=c2,processDelta=bY,frame=c0,frameReal=c1,now=cl,nowReal=cm,delta=c4}bV(bF,b4,b7,1)while ce do cd(b7)end;co=co+1;c2=c2+bY end;if cp then c3=cn end end end}cd=function(b7)if not ce then return end;ce=false;local cq=false;local bL={}bX(ca,b4,b7)for aO,cr in pairs(ca)do b4:remove(aO)cc[aO]=nil;if cb[aO]~=nil then cb[aO]=nil;c8:remove(aO)end end;ca={}for aO,cp in pairs(cb)do b4:set(aO,cc[aO])b4:setData(aO,c8:getData(aO))c8:remove(aO)if table.getn(cp.received)>0 then bL[aO]=cp.received;cq=true end end;cb={}for aO,cr in pairs(c9)do b4:set(aO,cc[aO])b4:setData(aO,c7:getData(aO))c7:remove(aO)bL[aO]=cc[aO].components;cq=true end;c9={}if cq then bW(bL,b4,b7)bL=nil end end;b4=aN.new(aG)c7=aN.new(aG)c8=aN.new(aG)bU=b1.new(aG,b4)if bq~=nil then for aq,b6 in pairs(bq)do aG.addSystem(b6)end end;if not y.disableDefaultSystems then aG.addSystem(bQ.Util.BasePartToEntityProcessInSystem)aG.addSystem(bQ.Util.MoveForwardSystem)aG.addSystem(bQ.Util.EntityToBasePartProcessOutSystem)aG.addSystem(bQ.Util.BasePartToEntityTransformSystem)aG.addSystem(bQ.Util.EntityToBasePartTransformSystem)aG.addSystem(bQ.Util.EntityToBasePartInterpolationTransformSystem)aG.addSystem(bQ.Util.EntityToBasePartInterpolationCustomTransformSystem)end;if not y.disableAutoUpdate then aG._steppedConn=a.Stepped:Connect(function()aG.update('processIn',os.clock())aG.update('process',os.clock())aG.update('processOut',os.clock())end)aG._heartbeatConn=a.Heartbeat:Connect(function()aG.update('transform',os.clock())end)aG._renderSteppedConn=a.RenderStepped:Connect(function()aG.update('render',os.clock())end)end;return aG end;bQ.Util={}function bQ.Util.NewBasePartEntity(aG,cs,ct,cu,cv)local aO=aG.create()aG.set(aO,bQ.Util.BasePartComponent,cs)aG.set(aO,bQ.Util.PositionComponent,cs.CFrame.Position)aG.set(aO,bQ.Util.RotationComponent,cs.CFrame.RightVector,cs.CFrame.UpVector,cs.CFrame.LookVector)if ct then aG.set(aO,bQ.Util.BasePartToEntitySyncComponent)end;if cu then aG.set(aO,bQ.Util.EntityToBasePartSyncComponent)end;if cv then aG.set(aO,bQ.Util.PositionInterpolationComponent,cs.CFrame.Position)aG.set(aO,bQ.Util.RotationInterpolationComponent,cs.CFrame.RightVector,cs.CFrame.UpVector,cs.CFrame.LookVector)end;return aO end;bQ.Util.BasePartComponent=ay.register('BasePart',function(cw)if cw==nil or cw['IsA']==nil or cw:IsA('BasePart')==false then error("This component only works with BasePart objects")end;return cw end)bQ.Util.BasePartToEntitySyncComponent=ay.register('BasePartToEntitySync',nil,true)bQ.Util.EntityToBasePartSyncComponent=ay.register('EntityToBasePartSync',nil,true)bQ.Util.PositionComponent=ay.register('Position',function(cx)if cx~=nil and typeof(cx)~='Vector3'then error("This component only works with Vector3 objects")end;if cx==nil then cx=Vector3.new(0,0,0)end;return cx end)bQ.Util.PositionInterpolationComponent=ay.register('PositionInterpolation',function(cx)if cx~=nil and typeof(cx)~='Vector3'then error("This component only works with Vector3 objects")end;if cx==nil then cx=Vector3.new(0,0,0)end;return{cx,cx}end)bQ.Util.InterpolationCustomComponent=ay.register('InterpolationCustom',function(cy,cz,cA,cB,cC,cD)if cy==nil then return nil end;return{cy,cz,cA,cB,cC,cD}end)local cE=Vector3.new(1,0,0)local cF=Vector3.new(0,1,0)local cG=Vector3.new(0,0,1)bQ.Util.RotationComponent=ay.register('Rotation',function(cH,cI,cJ)if cH~=nil and typeof(cH)~='Vector3'then error("This component only works with Vector3 objects [param=rightVector]")end;if cI~=nil and typeof(cI)~='Vector3'then error("This component only works with Vector3 objects [param=upVector]")end;if cJ~=nil and typeof(cJ)~='Vector3'then error("This component only works with Vector3 objects [param=lookVector]")end;if cH==nil then cH=cE end;if cI==nil then cI=cF end;if cJ==nil then cJ=cG end;return{cH,cI,cJ}end)bQ.Util.RotationInterpolationComponent=ay.register('RotationInterpolation',function(cH,cI,cJ)if cH~=nil and typeof(cH)~='Vector3'then error("This component only works with Vector3 objects [param=rightVector]")end;if cI~=nil and typeof(cI)~='Vector3'then error("This component only works with Vector3 objects [param=upVector]")end;if cJ~=nil and typeof(cJ)~='Vector3'then error("This component only works with Vector3 objects [param=lookVector]")end;if cH==nil then cH=cE end;if cI==nil then cI=cF end;if cJ==nil then cJ=cG end;return{{cH,cI,cJ},{cH,cI,cJ}}end)bQ.Util.MoveForwardComponent=ay.register('MoveForward',nil,true)bQ.Util.MoveSpeedComponent=ay.register('MoveSpeed',function(cK)if cK==nil or typeof(cK)~='number'then error("This component only works with number value")end;return cK end)local function cL(b7,aG,bi,aM,aK,cM,cN,cO)local cP=false;local cs=cM[aK]if cs~=nil then local cx=cN[aK]local cQ=cs.CFrame.Position;if cx==nil or not l(cQ,cx)then cN[aK]=cQ;cP=true end;local cR=cO[aK]local cH=cs.CFrame.RightVector;local cI=cs.CFrame.UpVector;local cJ=cs.CFrame.LookVector;if cR==nil or not l(cH,cR[1])or not l(cI,cR[2])or not l(cJ,cR[3])then cO[aK]={cH,cI,cJ}cP=true end end;return cP end;bQ.Util.BasePartToEntityProcessInSystem=a_.register({name='BasePartToEntityProcessIn',step='processIn',order=10,requireAll={bQ.Util.BasePartComponent,bQ.Util.PositionComponent,bQ.Util.RotationComponent,bQ.Util.BasePartToEntitySyncComponent},rejectAny={bQ.Util.PositionInterpolationComponent,bQ.Util.RotationInterpolationComponent},update=cL})bQ.Util.BasePartToEntityTransformSystem=a_.register({name='BasePartToEntityTransform',step='transform',order=10,requireAll={bQ.Util.BasePartComponent,bQ.Util.PositionComponent,bQ.Util.RotationComponent,bQ.Util.BasePartToEntitySyncComponent},rejectAny={bQ.Util.PositionInterpolationComponent,bQ.Util.RotationInterpolationComponent},update=cL})local function cS(b7,aG,bi,aM,aK,cM,cN,cO)if not bi then return false end;local cP=false;local cs=cM[aK]local cx=cN[aK]local cR=cO[aK]if cs~=nil then local cQ=cs.CFrame.Position;local cH=cs.CFrame.RightVector;local cI=cs.CFrame.UpVector;local cJ=cs.CFrame.LookVector;local cT=cs.CFrame;if cx~=nil and not l(cQ,cx)then cT=CFrame.fromMatrix(cx,cH,cI,cJ*-1)cP=true end;if cR~=nil then if not l(cH,cR[1])or not l(cI,cR[2])or not l(cJ,cR[3])then cT=CFrame.fromMatrix(cT.Position,cR[1],cR[2],cR[3]*-1)cP=true end end;if cP then cs.CFrame=cT end end;return cP end;bQ.Util.EntityToBasePartProcessOutSystem=a_.register({name='EntityToBasePartProcess',step='processOut',order=100,requireAll={bQ.Util.BasePartComponent,bQ.Util.PositionComponent,bQ.Util.RotationComponent,bQ.Util.EntityToBasePartSyncComponent},update=cS})bQ.Util.EntityToBasePartTransformSystem=a_.register({name='EntityToBasePartTransform',step='transform',order=100,requireAll={bQ.Util.BasePartComponent,bQ.Util.PositionComponent,bQ.Util.RotationComponent,bQ.Util.EntityToBasePartSyncComponent},rejectAny={bQ.Util.PositionInterpolationComponent,bQ.Util.RotationInterpolationComponent},update=cS})local cU=1;bQ.Util.EntityToBasePartInterpolationTransformSystem=a_.register({name='EntityToBasePartInterpolationTransform',step='transform',order=100,requireAll={bQ.Util.BasePartComponent,bQ.Util.PositionComponent,bQ.Util.RotationComponent,bQ.Util.PositionInterpolationComponent,bQ.Util.RotationInterpolationComponent,bQ.Util.EntityToBasePartSyncComponent},rejectAny={bQ.Util.InterpolationCustomComponent},beforeUpdate=function(b7,bG,aG,b6)cU=bG end,update=function(b7,aG,bi,aM,aK,cM,cN,cO,cV,cW)local cs=cM[aK]local cx=cN[aK]local cR=cO[aK]if cs~=nil then local cT=cs.CFrame;if cx~=nil then local cH=cs.CFrame.RightVector;local cI=cs.CFrame.UpVector;local cJ=cs.CFrame.LookVector;if not l(cV[aK][1],cx)then cV[aK][2]=cV[aK][1]cV[aK][1]=cx end;local cX=cV[aK][2]cT=CFrame.fromMatrix(cX:Lerp(cx,cU),cH,cI,cJ*-1)end;if cR~=nil then if not l(cW[aK][1][1],cR[1])or not l(cW[aK][1][2],cR[2])or not l(cW[aK][1][3],cR[3])then cW[aK][2]=cW[aK][1]cW[aK][1]=cR end;local cY=cW[aK][2]cT=CFrame.fromMatrix(cT.Position,cY[1]:Lerp(cR[1],cU),cY[2]:Lerp(cR[2],cU),(cY[3]*-1):Lerp(cR[3]*-1,cU))end;cs.CFrame=cT end;return false end})bQ.Util.EntityToBasePartInterpolationCustomTransformSystem=a_.register({name='EntityToBasePartInterpolationCustomTransform',step='transform',order=100,requireAll={bQ.Util.BasePartComponent,bQ.Util.PositionComponent,bQ.Util.RotationComponent,bQ.Util.InterpolationCustomComponent,bQ.Util.EntityToBasePartSyncComponent},update=function(b7,aG,bi,aM,aK,cM,cN,cO,cZ)local cs=cM[aK]local cx=cN[aK]local cR=cO[aK]local c_=cZ[aK]if cs~=nil and cx~=nil and cR~=nil and c_~=nil then local cy=c_[1]local cz=c_[2]local d0=(b7.frame-cz)/cy;local cT=CFrame.fromMatrix(c_[3],c_[4],c_[5],c_[6]*-1)cs.CFrame=cT:Lerp(CFrame.fromMatrix(cx,cR[1],cR[2],cR[3]*-1),d0)end;return false end})local d1=1;bQ.Util.MoveForwardSystem=a_.register({name='MoveForward',step='process',requireAll={bQ.Util.MoveSpeedComponent,bQ.Util.PositionComponent,bQ.Util.RotationComponent,bQ.Util.MoveForwardComponent},beforeUpdate=function(b7,bG,aG,b6)d1=aG.frequency/60 end,update=function(b7,aG,bi,aM,aK,d2,cN,cO,d3)local cx=cN[aK]if cx~=nil then local cR=cO[aK]if cR~=nil then local cK=d2[aK]if cK~=nil then cN[aK]=cx+cK/d1*cR[3]return true end end end;return false end})return bQ