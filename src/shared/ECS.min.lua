--[[
	Roblox-ECS v1.1

	Roblox-ECS is a tiny and easy to use ECS (Entity Component System) engine for
	game development on the Roblox platform

	This is a minified version of Roblox-ECS, to see the full source code visit
	https://github.com/nidorx/roblox-ecs

	Discussions about this script are at https://devforum.roblox.com/t/841175

	This code was minified using https://goonlinetools.com/lua-minifier/

	------------------------------------------------------------------------------

	MIT License

	Copyright (c) 2020 Alex Rodin

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.
]]
local a=game:GetService('RunService')local function b()return DateTime.now().UnixTimestampMillis end;local c={}local d={}local function e(f)local g=c[f]if g~=nil then if g+1000<b()then print(d[f],' times > ',f)c[f]=b()d[f]=0;return end;d[f]=d[f]+1 else c[f]=b()d[f]=1 end end;local h=0.000000001;local function i(j,k)if j==k then return true end;return math.abs(k-j)<h end;local function l(m,n)if m==n then return true end;if not i(m.X,n.X)or not i(m.Y,n.Y)or not i(m.Z,n.Z)then return false else return true end end;local function o(p)if p==nil then p={}end;local q={}local r={}for s,t in pairs(p)do if t~=nil and q[t]==nil then table.insert(r,t)q[t]=true end end;table.sort(r)return r end;local function u(v)v=o(v)return'_'..table.concat(v,'_'),v end;local w={}local function x(y)local z={}if y==nil then y={}end;if y.requireAll==nil and y.requireAny==nil then error('It is necessary to define the components using the "requireAll" or "requireAny" parameters')end;if y.requireAll~=nil and y.requireAny~=nil then error('It is not allowed to use the "requireAll" and "requireAny" settings simultaneously')end;if y.requireAll~=nil then y.requireAllOriginal=y.requireAll;y.requireAll=o(y.requireAll)if table.getn(y.requireAll)==0 then error('You must enter at least one component id in the "requireAll" field')end elseif y.requireAny~=nil then y.requireAnyOriginal=y.requireAny;y.requireAny=o(y.requireAny)if table.getn(y.requireAny)==0 then error('You must enter at least one component id in the "requireAny" field')end end;if y.rejectAll~=nil and y.rejectAny~=nil then error('It is not allowed to use the "rejectAll" and "rejectAny" settings simultaneously')end;if y.rejectAll~=nil then y.rejectAll=o(y.rejectAll)if table.getn(y.rejectAll)==0 then error('You must enter at least one component id in the "rejectAll" field')end elseif y.rejectAny~=nil then y.rejectAny=o(y.rejectAny)if table.getn(y.rejectAny)==0 then error('You must enter at least one component id in the "rejectAny" field')end end;local A,B=u(y.requireAll)local C,D=u(y.requireAny)local E,F=u(y.rejectAll)local G,H=u(y.rejectAny)local I=y.requireAllOriginal;if I==nil then I=y.requireAnyOriginal end;return{components=I,match=function(I)local J=z[I]if J==false then return false elseif J==true then return true else local K=w[I]if K==nil then K={matchAny={},matchAll={},rejectAny={},rejectAll={}}w[I]=K end;if G~='_'then if K.rejectAny[G]or K.rejectAll[G]then z[I]=false;return false end;for s,t in pairs(H)do if table.find(I,t)then z[I]=false;K.matchAny[G]=true;K.rejectAny[G]=true;return false end end end;if E~='_'then if K.rejectAll[E]then z[I]=false;return false end;local L=true;for s,t in pairs(F)do if not table.find(I,t)then L=false;break end end;if L then z[I]=false;K.matchAll[E]=true;K.rejectAll[E]=true;return false end end;if C~='_'then if K.matchAny[C]or K.matchAll[C]then z[I]=true;return true end;for s,t in pairs(D)do if table.find(I,t)then K.matchAny[C]=true;z[I]=true;return true end end end;if A~='_'then if K.matchAll[A]then z[I]=true;return true end;local L=true;for s,t in pairs(B)do if not table.find(I,t)then L=false;break end end;if L then z[I]=true;K.matchAll[A]=true;K.rejectAll[A]=true;return true end end;z[I]=false;return false end end}end;local M={}local N=b()local O={}O.__index=O;function O.get(I)local P;P,I=u(I)if M[P]==nil then M[P]=setmetatable({id=P,components=I},O)N=b()end;return M[P]end;function O:with(Q)if table.find(self.components,Q)~=nil then return self end;local R=table.getn(self.components)local S=table.create(R+1)S[0]=Q;table.move(self.components,1,R,2,S)return O.get(S)end;function O:without(Q)if table.find(self.components,Q)==nil then return self end;local R=table.getn(self.components)local S=table.create(R-1)local T=1;for U=1,R do if self.components[U]~=Q then S[T]=self.components[U]T=T+1 end end;return O.get(S)end;local V=O.get({})local W={}local X={}local Y={}local Z={}local function _(a0)return a0 end;local a1={register=function(a2,a3,a4)if a2==nil then error('Component name is required for registration')end;if a3~=nil and type(a3)~='function'then error('The component constructor must be a function, or nil')end;if a3==nil then a3=_ end;if a4==nil then a4=false end;if Z[a2]~=nil then error('Another component already registered with that name')end;local a5=table.getn(W)+1;Z[a2]=a5;table.insert(W,a2)table.insert(Y,a4)table.insert(X,a3)return a5 end}local a6=a1.register('_ECS_ENTITY_ID_')local a7={}a7.__index=a7;local a8=300;function a7.new(a9,aa)local ab={}ab[a6]=table.create(a8)for s,ac in pairs(aa.components)do if Y[ac]then ab[ac]=nil else ab[ac]=table.create(a8)end end;return setmetatable({version=0,count=0,world=a9,archetype=aa,buffers=ab},a7)end;function a7:clear(ad)local ab=self.buffers;for ae in pairs(ab)do ab[ae][ad]=nil end end;function a7:getValue(ad,Q)local ab=self.buffers;if ab[Q]==nil then return nil end;return ab[Q][ad]end;function a7:setValue(ad,Q,a0)local ab=self.buffers;if ab[Q]==nil then return end;ab[Q][ad]=a0 end;function a7:get(ad)local af={}local ab=self.buffers;for Q in pairs(ab)do af[Q]=ab[Q][ad]end;return af end;function a7:set(ad,af)local ab=self.buffers;for Q,a0 in pairs(af)do if ab[Q]~=nil then ab[Q][ad]=a0 end end end;function a7:setEntityId(ad,ag)self.buffers[a6][ad]=ag end;local ah={}ah.__index=ah;function ah.new(a9)return setmetatable({world=a9,COUNT=0,ENTITIES={},ARCHETYPES={}},ah)end;function ah:set(ai,aa)local aj=aa.id;local ag=self.ENTITIES[ai]local ak=nil;if ag~=nil then if ag.archetype==aj then return end;ak=self.ARCHETYPES[ag.archetype].chunks[ag.chunk]:get(ag.chunkIndex)self:remove(ai)end;if self.ARCHETYPES[aj]==nil then self.ARCHETYPES[aj]={count=0,lastChunk=1,nextChunkIndex=1,chunks={a7.new(self.world,aa)}}end;local al=self.ARCHETYPES[aj]self.ENTITIES[ai]={archetype=aj,chunk=al.lastChunk,chunkIndex=al.nextChunkIndex}self.COUNT=self.COUNT+1;local am=al.chunks[al.lastChunk]am:clear(al.nextChunkIndex)if ak~=nil then am:set(al.nextChunkIndex,ak)end;am:setEntityId(al.nextChunkIndex,ai)al.count=al.count+1;am.count=al.nextChunkIndex;al.nextChunkIndex=al.nextChunkIndex+1;am.version=self.world.version;if al.nextChunkIndex>a8 then al.lastChunk=al.lastChunk+1;al.nextChunkIndex=1;al.chunks[al.lastChunk]=a7.new(self.world,aa)end end;function ah:remove(ai)local ag=self.ENTITIES[ai]if ag==nil then return end;local al=self.ARCHETYPES[ag.archetype]local am=al.chunks[ag.chunk]am:clear(ag.chunkIndex)am.count=am.count-1;self.ENTITIES[ai]=nil;self.COUNT=self.COUNT-1;al.count=al.count-1;if al.nextChunkIndex==1 then al.chunks[al.lastChunk]=nil;al.lastChunk=al.lastChunk-1;al.nextChunkIndex=a8+1 end;if al.count>0 then if al.nextChunkIndex>1 then if not(al.lastChunk==ag.chunk and al.nextChunkIndex-1==ag.chunkIndex)then local an=al.chunks[al.lastChunk]:get(al.nextChunkIndex-1)al.chunks[ag.chunk]:set(ag.chunkIndex,an)local ao=an[a6]local ap=self.ENTITIES[ao]ap.chunk=ag.chunk;ap.chunkIndex=ag.chunkIndex end;al.nextChunkIndex=al.nextChunkIndex-1;al.chunks[al.lastChunk]:clear(al.nextChunkIndex)end else al.nextChunkIndex=al.nextChunkIndex-1 end end;function ah:count()return self.COUNT end;function ah:clear(ai)local ag=self.ENTITIES[ai]if ag==nil then return end;local am=self.ARCHETYPES[ag.archetype].chunks[ag.chunk]am:clear(ag.chunkIndex)end;function ah:getValue(ai,Q)local ag=self.ENTITIES[ai]if ag==nil then return nil end;return self.ARCHETYPES[ag.archetype].chunks[ag.chunk]:getValue(ag.chunkIndex,Q)end;function ah:setValue(ai,Q,a0)local ag=self.ENTITIES[ai]if ag==nil then return end;local am=self.ARCHETYPES[ag.archetype].chunks[ag.chunk]am:setValue(ag.chunkIndex,Q,a0)end;function ah:getData(ai)local ag=self.ENTITIES[ai]if ag==nil then return nil end;local am=self.ARCHETYPES[ag.archetype].chunks[ag.chunk]return am:get(ag.chunkIndex)end;function ah:setData(ai,Q,af)local ag=self.ENTITIES[ai]if ag==nil then return end;local am=self.ARCHETYPES[ag.archetype].chunks[ag.chunk]am:set(ag.chunkIndex,Q,af)end;function ah:getEntityChunk(ai)local ag=self.ENTITIES[ai]if ag==nil then return end;return self.ARCHETYPES[ag.archetype].chunks[ag.chunk],ag.chunkIndex end;function ah:filterChunks(aq)local ar={}for aj,al in pairs(self.ARCHETYPES)do if aq(M[aj].components)then for U,am in pairs(al.chunks)do table.insert(ar,am)end end end;return ar end;local as={}local at={}local au={}function au.register(y)if y==nil then error('System configuration is required for its creation')end;if y.name==nil then error('The system "name" is required for registration')end;if at[y.name]~=nil then error('Another System already registered with that name')end;local av=x(y)if y.step==nil then y.step='transform'end;if y.step~='render'and y.step~='process'and y.step~='processIn'and y.step~='processOut'and y.step~='transform'then error('The "step" parameter must be "render", "process", "transform", "processIn" or "processOut"')end;if y.order==nil or y.order<0 then y.order=50 end;table.insert(as,{name=y.name,filter=av,requireAll=y.requireAll,requireAny=y.requireAny,requireAllOriginal=y.requireAllOriginal,requireAnyOriginal=y.requireAnyOriginal,rejectAll=y.rejectAll,rejectAny=y.rejectAny,beforeUpdate=y.beforeUpdate,update=y.update,onEnter=y.onEnter,step=y.step,order=y.order})local a5=table.getn(as)at[y.name]=a5;return a5 end;local function aw(a9,ax)local ay={processIn={},process={},processOut={},transform={},render={}}local az={}for ae,aA in pairs(ax)do if aA.update~=nil then if ay[aA.step][aA.order]==nil then ay[aA.step][aA.order]={}end;table.insert(ay[aA.step][aA.order],aA)end;if aA.onEnter~=nil then table.insert(az,aA)end end;local aB=function(aC,aD,aE,aF)for U,aG in pairs(ay[aC])do for aH,aA in pairs(aG)do aA.lastUpdate=aE;local aI=aA.requireAllOriginal;if aI==nil then aI=aA.requireAnyOriginal end;local aJ=table.getn(aI)local aK=aA.version;local ar=aD:filterChunks(aA.filter.match)local aL=aA.update;a9.version=a9.version+1;if aA.beforeUpdate~=nil then aA.beforeUpdate(aE,aF,a9,aA)end;for ae,am in pairs(ar)do local aM=am.version==0 or am.version>aK;local ab=am.buffers;local aN=ab[a6]local aO=table.create(aJ)local aP=false;for aQ,aR in ipairs(aI)do if ab[aR]~=nil then aO[aQ]=ab[aR]else aO[aQ]={}end end;for ad=1,am.count do if aL(aE,a9,aM,aN[ad],ad,table.unpack(aO))then aP=true end end;if aP then am.version=a9.version end end;aA.version=a9.version end end end;local aS=function(aT,aD,aE)a9.version=a9.version+1;for ai,aU in pairs(aT)do local aV=x({requireAny=aU})local am,ad=aD:getEntityChunk(ai)if am~=nil then local ab=am.buffers;for aH,aA in pairs(az)do if aA.filter.match(am.archetype.components)then local aI=aA.requireAllOriginal;if aI==nil then aI=aA.requireAnyOriginal end;if aV.match(aI)then local aO=table.create(table.getn(aI))for aQ,aR in ipairs(aI)do if ab[aR]~=nil then aO[aQ]=ab[aR]else aO[aQ]={}end end;if aA.onEnter(aE,a9,ai,ad,table.unpack(aO))then am.version=a9.version end end end end end end end;return aB,aS end;local aW={Component=a1,System=au,Filter=x}function aW.newWorld(ax,y)if y==nil then y={}end;if y.frequency==nil then y.frequency=30 end;local aX=math.round(math.abs(y.frequency)/2)*2;if aX<2 then aX=2 end;if y.frequency~=aX then y.frequency=aX;print(string.format(">>> ATTENTION! The execution frequency of world has been changed to %d <<<",aX))end;local aY=1;local aZ={}local a_,b0;local b1=1000/y.frequency/1000;local aF=1;local b2=nil;local b3=0;local b4=0;local b5=0;local b6=0;local b7=0;local b8=10;local b9=0;local aD;local ba;local bb;local bc={}local bd={}local be={}local bf={}local a9;local bg;local bh=false;a9={version=0,frequency=y.frequency,create=function()local a5=aY;aY=aY+1;ba:set(a5,V)bc[a5]=true;bf[a5]=V;bh=true;return a5 end,get=function(ag,Q)if bc[ag]==true then return ba:getValue(ag,Q)else return aD:getValue(ag,Q)end end,set=function(ag,Q,...)local aa=bf[ag]if aa==nil then return end;bh=true;local bi=aa:with(Q)local bj=aa~=bi;if bj then bf[ag]=bi end;local a0=X[Q](table.unpack({...}))if bc[ag]==true then if bj then ba:set(ag,bi)end;ba:setValue(ag,Q,a0)else if bj then if be[ag]==nil then be[ag]={received={},lost={}}bb:set(ag,bi)bb:setData(ag,aD:getData(ag))else bb:set(ag,bi)end end;if be[ag]~=nil then bb:setValue(ag,Q,a0)local bk=false;for ae,t in pairs(be[ag].lost)do if t==Q then table.remove(be[ag].lost,ae)bk=true;break end end;if not bk then table.insert(be[ag].received,Q)end end;aD:setValue(ag,Q,a0)end end,remove=function(ag,Q)local aa=bf[ag]if aa==nil then return end;if bd[ag]==true then return end;bh=true;if Q==nil then if bc[ag]==true then ba:remove(ag)bc[ag]=nil;bf[ag]=nil else if bd[ag]==nil then bd[ag]=true end end else local bi=aa:without(Q)local bj=aa~=bi;if bj then bf[ag]=bi end;if bc[ag]==true then if bj then ba:set(ag,bi)end else if bj then if be[ag]==nil then be[ag]={received={},lost={}}bb:set(ag,bi)bb:setData(ag,aD:getData(ag))else bb:set(ag,bi)end end;if be[ag]~=nil then bb:setValue(ag,Q,nil)local bk=false;for ae,t in pairs(be[ag].received)do if t==Q then table.remove(be[ag].received,ae)bk=true;break end end;if not bk then table.insert(be[ag].lost,Q)end end;aD:setValue(ag,Q,nil)end end end,has=function(ag,Q)if bf[ag]==nil then return false end;return bf[ag]:has(Q)end,forEach=function(av,bl)local bm=false;local bn=function()bm=true end;local ar=aD:filterChunks(av.match)for ae,am in pairs(ar)do local ab=am.buffers;local aO=table.create(table.getn(av.components))for aQ,aR in ipairs(av.components)do if ab[aR]~=nil then aO[aQ]=ab[aR]else aO[aQ]={}end end;local aN=ab[a6]local aP=false;for ad=1,am.count do if bl(bn,aN[ad],ad,table.unpack(aO))then aP=true end;if bm then break end end;if aP then am.version=a9.version end;if bm then break end end end,addSystem=function(bo,bp,y)if bo==nil then return end;if as[bo]==nil then error('There is no registered system with the given ID')end;if aZ[bo]~=nil then return end;if aD:count()>0 or ba:count()>0 then error('Adding systems is not allowed after adding entities in the world')end;if y==nil then y={}end;local aA={id=bo,name=as[bo].name,requireAll=as[bo].requireAll,requireAny=as[bo].requireAny,requireAllOriginal=as[bo].requireAllOriginal,requireAnyOriginal=as[bo].requireAnyOriginal,rejectAll=as[bo].rejectAll,rejectAny=as[bo].rejectAny,filter=as[bo].filter,beforeUpdate=as[bo].beforeUpdate,update=as[bo].update,onEnter=as[bo].onEnter,step=as[bo].step,order=as[bo].order,version=0,lastUpdate=b5,config=y}if bp~=nil and bp<0 then aA.order=50 end;aZ[bo]=aA;b9=0 end,alive=function(ag)if bf[ag]==nil then return false end;if bc[ag]==true then return false end;if bd[ag]==true then return false end;return true end,destroy=function()if a9._steppedConn~=nil then a9._steppedConn:Disconnect()a9._steppedConn=nil end;if a9._heartbeatConn~=nil then a9._heartbeatConn:Disconnect()a9._heartbeatConn=nil end;if a9._renderSteppedConn~=nil then a9._renderSteppedConn:Disconnect()a9._renderSteppedConn=nil end;aD=nil;ba=nil;bb=nil;be=nil;bd=nil;aZ=nil;a_=nil;b0=nil;bg=nil;bf=nil;a9.create=nil;a9.set=nil;a9.get=nil;a9.remove=nil;a9.has=nil;a9.forEach=nil;a9.addSystem=nil;a9.alive=nil;a9.update=nil;a9.destroy=nil;a9=nil end,update=function(aC,bq)if not a:IsRunning()then return end;if b2==nil then b2=bq end;bq=bq-b2;if b9<N then a_,b0=aw(a9,aZ)b9=N end;if aC~='process'then if b5~=b6 then aF=1+(bq-b5)/b1 else aF=1 end;if aC=='processIn'then b4=bq;if b3==0 then b3=b4 end;if b5==0 then b5=b4;b6=b4 end;b7=b4-b3;aF=1 elseif aC=='render'then b3=b4 end;a_(aC,aD,{process=b5,frame=b4,delta=b7},aF)while bh do bg()end else local br=b5;local bs=0;local bt=false;while b5<b4 and bs<b8 do bt=true;if b9<N then a_,b0=aw(a9,aZ)b9=N end;a_(aC,aD,{process=b5,frame=b4,delta=b7},1)while bh do bg()end;bs=bs+1;b5=b5+b1 end;if bt then b6=br end end end}bg=function()if not bh then return end;bh=false;for ai,bu in pairs(bd)do aD:remove(ai)bf[ai]=nil;if be[ai]~=nil then be[ai]=nil;bb:remove(ai)end end;local bv=false;local aT={}for ai,bt in pairs(be)do aD:set(ai,bf[ai])aD:setData(ai,bb:getData(ai))bb:remove(ai)if table.getn(bt.received)>0 then aT[ai]=bt.received;bv=true end end;be={}for ai,bu in pairs(bc)do aD:set(ai,bf[ai])aD:setData(ai,ba:getData(ai))ba:remove(ai)aT[ai]=bf[ai].components;bv=true end;bc={}if bv then b0(aT,aD)aT=nil end end;aD=ah.new(a9)ba=ah.new(a9)bb=ah.new(a9)if ax~=nil then for U,aA in pairs(ax)do a9.addSystem(aA)end end;if not y.disableDefaultSystems then a9.addSystem(aW.Util.BasePartToEntityProcessInSystem)a9.addSystem(aW.Util.MoveForwardSystem)a9.addSystem(aW.Util.EntityToBasePartProcessOutSystem)a9.addSystem(aW.Util.BasePartToEntityTransformSystem)a9.addSystem(aW.Util.EntityToBasePartTransformSystem)a9.addSystem(aW.Util.EntityToBasePartInterpolationTransformSystem)end;if not y.disableAutoUpdate then a9._steppedConn=a.Stepped:Connect(function()a9.update('processIn',tick())a9.update('process',tick())a9.update('processOut',tick())end)a9._heartbeatConn=a.Heartbeat:Connect(function()a9.update('transform',tick())end)a9._renderSteppedConn=a.RenderStepped:Connect(function()a9.update('render',tick())end)end;return a9 end;aW.Util={}function aW.Util.NewBasePartEntity(a9,bw,bx,by,bz)local ai=a9.create()a9.set(ai,aW.Util.BasePartComponent,bw)a9.set(ai,aW.Util.PositionComponent,bw.CFrame.Position)a9.set(ai,aW.Util.RotationComponent,bw.CFrame.RightVector,bw.CFrame.UpVector,bw.CFrame.LookVector)if bx then a9.set(ai,aW.Util.BasePartToEntitySyncComponent)end;if by then a9.set(ai,aW.Util.EntityToBasePartSyncComponent)end;if bz then a9.set(ai,aW.Util.PositionInterpolationComponent,bw.CFrame.Position)a9.set(ai,aW.Util.RotationInterpolationComponent,bw.CFrame.RightVector,bw.CFrame.UpVector,bw.CFrame.LookVector)end;return ai end;aW.Util.BasePartComponent=a1.register('BasePart',function(bA)if bA==nil or bA['IsA']==nil or bA:IsA('BasePart')==false then error("This component only works with BasePart objects")end;return bA end)aW.Util.BasePartToEntitySyncComponent=a1.register('BasePartToEntitySync',nil,true)aW.Util.EntityToBasePartSyncComponent=a1.register('EntityToBasePartSync',nil,true)aW.Util.PositionComponent=a1.register('Position',function(bB)if bB~=nil and typeof(bB)~='Vector3'then error("This component only works with Vector3 objects")end;if bB==nil then bB=Vector3.new(0,0,0)end;return bB end)aW.Util.PositionInterpolationComponent=a1.register('PositionInterpolation',function(bB)if bB~=nil and typeof(bB)~='Vector3'then error("This component only works with Vector3 objects")end;if bB==nil then bB=Vector3.new(0,0,0)end;return{bB,bB}end)local bC=Vector3.new(1,0,0)local bD=Vector3.new(0,1,0)local bE=Vector3.new(0,0,1)aW.Util.RotationComponent=a1.register('Rotation',function(bF,bG,bH)if bF~=nil and typeof(bF)~='Vector3'then error("This component only works with Vector3 objects [param=rightVector]")end;if bG~=nil and typeof(bG)~='Vector3'then error("This component only works with Vector3 objects [param=upVector]")end;if bH~=nil and typeof(bH)~='Vector3'then error("This component only works with Vector3 objects [param=lookVector]")end;if bF==nil then bF=bC end;if bG==nil then bG=bD end;if bH==nil then bH=bE end;return{bF,bG,bH}end)aW.Util.RotationInterpolationComponent=a1.register('RotationInterpolation',function(bF,bG,bH)if bF~=nil and typeof(bF)~='Vector3'then error("This component only works with Vector3 objects [param=rightVector]")end;if bG~=nil and typeof(bG)~='Vector3'then error("This component only works with Vector3 objects [param=upVector]")end;if bH~=nil and typeof(bH)~='Vector3'then error("This component only works with Vector3 objects [param=lookVector]")end;if bF==nil then bF=bC end;if bG==nil then bG=bD end;if bH==nil then bH=bE end;return{{bF,bG,bH},{bF,bG,bH}}end)aW.Util.MoveForwardComponent=a1.register('MoveForward',nil,true)aW.Util.MoveSpeedComponent=a1.register('MoveSpeed',function(bI)if bI==nil or typeof(bI)~='number'then error("This component only works with number value")end;return bI end)local function bJ(aE,a9,aM,ag,ad,bK,bL,bM)local bN=false;local bw=bK[ad]if bw~=nil then local bB=bL[ad]local bO=bw.CFrame.Position;if bB==nil or not l(bO,bB)then bL[ad]=bO;bN=true end;local bP=bM[ad]local bF=bw.CFrame.RightVector;local bG=bw.CFrame.UpVector;local bH=bw.CFrame.LookVector;if bP==nil or not l(bF,bP[1])or not l(bG,bP[2])or not l(bH,bP[3])then bM[ad]={bF,bG,bH}bN=true end end;return bN end;aW.Util.BasePartToEntityProcessInSystem=au.register({name='BasePartToEntityProcessIn',step='processIn',order=10,requireAll={aW.Util.BasePartComponent,aW.Util.PositionComponent,aW.Util.RotationComponent,aW.Util.BasePartToEntitySyncComponent},rejectAny={aW.Util.PositionInterpolationComponent,aW.Util.RotationInterpolationComponent},update=bJ})aW.Util.BasePartToEntityTransformSystem=au.register({name='BasePartToEntityTransform',step='transform',order=10,requireAll={aW.Util.BasePartComponent,aW.Util.PositionComponent,aW.Util.RotationComponent,aW.Util.BasePartToEntitySyncComponent},rejectAny={aW.Util.PositionInterpolationComponent,aW.Util.RotationInterpolationComponent},update=bJ})local function bQ(aE,a9,aM,ag,ad,bK,bL,bM)if not aM then return false end;local bN=false;local bw=bK[ad]local bB=bL[ad]local bP=bM[ad]if bw~=nil then local bO=bw.CFrame.Position;local bF=bw.CFrame.RightVector;local bG=bw.CFrame.UpVector;local bH=bw.CFrame.LookVector;local bR=bw.CFrame;if bB~=nil and not l(bO,bB)then bR=CFrame.fromMatrix(bB,bF,bG,bH*-1)bN=true end;if bP~=nil then if not l(bF,bP[1])or not l(bG,bP[2])or not l(bH,bP[3])then bR=CFrame.fromMatrix(bR.Position,bP[1],bP[2],bP[3]*-1)bN=true end end;if bN then bw.CFrame=bR end end;return bN end;aW.Util.EntityToBasePartProcessOutSystem=au.register({name='EntityToBasePartProcess',step='processOut',order=100,requireAll={aW.Util.BasePartComponent,aW.Util.PositionComponent,aW.Util.RotationComponent,aW.Util.EntityToBasePartSyncComponent},update=bQ})aW.Util.EntityToBasePartTransformSystem=au.register({name='EntityToBasePartTransform',step='transform',order=100,requireAll={aW.Util.BasePartComponent,aW.Util.PositionComponent,aW.Util.RotationComponent,aW.Util.EntityToBasePartSyncComponent},rejectAny={aW.Util.PositionInterpolationComponent,aW.Util.RotationInterpolationComponent},update=bQ})local bS=1;aW.Util.EntityToBasePartInterpolationTransformSystem=au.register({name='EntityToBasePartInterpolationTransform',step='transform',order=100,requireAll={aW.Util.BasePartComponent,aW.Util.PositionComponent,aW.Util.RotationComponent,aW.Util.PositionInterpolationComponent,aW.Util.RotationInterpolationComponent,aW.Util.EntityToBasePartSyncComponent},beforeUpdate=function(aE,aF,a9,aA)bS=aF end,update=function(aE,a9,aM,ag,ad,bK,bL,bM,bT,bU)local bw=bK[ad]local bB=bL[ad]local bP=bM[ad]if bw~=nil then local bR=bw.CFrame;if bB~=nil then local bF=bw.CFrame.RightVector;local bG=bw.CFrame.UpVector;local bH=bw.CFrame.LookVector;if not l(bT[ad][1],bB)then bT[ad][2]=bT[ad][1]bT[ad][1]=bB end;local bV=bT[ad][2]bR=CFrame.fromMatrix(bV:Lerp(bB,bS),bF,bG,bH*-1)end;if bP~=nil then if not l(bU[ad][1][1],bP[1])or not l(bU[ad][1][2],bP[2])or not l(bU[ad][1][3],bP[3])then bU[ad][2]=bU[ad][1]bU[ad][1]=bP end;local bW=bU[ad][2]bR=CFrame.fromMatrix(bR.Position,bW[1]:Lerp(bP[1],bS),bW[2]:Lerp(bP[2],bS),(bW[3]*-1):Lerp(bP[3]*-1,bS))end;bw.CFrame=bR end;return false end})local bX=1;aW.Util.MoveForwardSystem=au.register({name='MoveForward',step='process',requireAll={aW.Util.MoveSpeedComponent,aW.Util.PositionComponent,aW.Util.RotationComponent,aW.Util.MoveForwardComponent},beforeUpdate=function(aE,aF,a9,aA)bX=a9.frequency/60 end,update=function(aE,a9,aM,ag,ad,bY,bL,bM,bZ)local bB=bL[ad]if bB~=nil then local bP=bM[ad]if bP~=nil then local bI=bY[ad]if bI~=nil then bL[ad]=bB+bI/bX*bP[3]return true end end end;return false end})return aW