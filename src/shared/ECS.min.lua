--[[
	Roblox-ECS v1.1  [2020-11-20 01:45]

	Roblox-ECS is a tiny and easy to use ECS (Entity Component System) engine for
	game development on the Roblox platform

	This is a minified version of Roblox-ECS, to see the full source code visit
	https://github.com/nidorx/roblox-ecs

	Discussions about this script are at https://devforum.roblox.com/t/841175

	This code was minified using https://goonlinetools.com/lua-minifier/

	------------------------------------------------------------------------------

	MIT License

	Copyright (c) 2020 Alex Rodin

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.
]]
local a=game:GetService('RunService')local b=0.000000001;local function c(d)if d==nil then d={}end;local e={}local f={}for g,h in pairs(d)do if h~=nil and e[h]==nil then table.insert(f,h)e[h]=true end end;table.sort(f)return f end;local function i(j)j=c(j)return'_'..table.concat(j,'_'),j end;local k={}local function l(m)local n={}if m==nil then m={}end;if m.requireAll==nil and m.requireAny==nil then error('It is necessary to define the components using the "requireAll" or "requireAny" parameters')end;if m.requireAll~=nil and m.requireAny~=nil then error('It is not allowed to use the "requireAll" and "requireAny" settings simultaneously')end;if m.requireAll~=nil then m.requireAllOriginal=m.requireAll;m.requireAll=c(m.requireAll)if table.getn(m.requireAll)==0 then error('You must enter at least one component id in the "requireAll" field')end elseif m.requireAny~=nil then m.requireAnyOriginal=m.requireAny;m.requireAny=c(m.requireAny)if table.getn(m.requireAny)==0 then error('You must enter at least one component id in the "requireAny" field')end end;if m.rejectAll~=nil and m.rejectAny~=nil then error('It is not allowed to use the "rejectAll" and "rejectAny" settings simultaneously')end;if m.rejectAll~=nil then m.rejectAll=c(m.rejectAll)if table.getn(m.rejectAll)==0 then error('You must enter at least one component id in the "rejectAll" field')end elseif m.rejectAny~=nil then m.rejectAny=c(m.rejectAny)if table.getn(m.rejectAny)==0 then error('You must enter at least one component id in the "rejectAny" field')end end;local o,p=i(m.requireAll)local q,r=i(m.requireAny)local s,t=i(m.rejectAll)local u,v=i(m.rejectAny)local w=m.requireAllOriginal;if w==nil then w=m.requireAnyOriginal end;return{components=w,match=function(w)local x=n[w]if x==false then return false elseif x==true then return true else local y=k[w]if y==nil then y={matchAny={},matchAll={},rejectAny={},rejectAll={}}k[w]=y end;if u~='_'then if y.rejectAny[u]or y.rejectAll[u]then n[w]=false;return false end;for g,h in pairs(v)do if table.find(w,h)then n[w]=false;y.matchAny[u]=true;y.rejectAny[u]=true;return false end end end;if s~='_'then if y.rejectAll[s]then n[w]=false;return false end;local z=true;for g,h in pairs(t)do if not table.find(w,h)then z=false;break end end;if z then n[w]=false;y.matchAll[s]=true;y.rejectAll[s]=true;return false end end;if q~='_'then if y.matchAny[q]or y.matchAll[q]then n[w]=true;return true end;for g,h in pairs(r)do if table.find(w,h)then y.matchAny[q]=true;n[w]=true;return true end end end;if o~='_'then if y.matchAll[o]then n[w]=true;return true end;local z=true;for g,h in pairs(p)do if not table.find(w,h)then z=false;break end end;if z then n[w]=true;y.matchAll[o]=true;y.rejectAll[o]=true;return true end end;n[w]=false;return false end end}end;local A=0;local B=1;local C={key=0,color=A}local function D(E,F)local G=F.right;F.right=G.left;if G.left~=C then G.left.parent=F end;G.parent=F.parent;if F.parent==C then E.root=G elseif F==F.parent.left then F.parent.left=G else F.parent.right=G end;G.left=F;F.parent=G end;local function H(E,F)local I=F.left;F.left=I.right;if I.right~=C then I.right.parent=F end;I.parent=F.parent;if F.parent==C then E.root=I elseif F==F.parent.right then F.parent.right=I else F.parent.left=I end;I.right=F;F.parent=I end;local function J(E,F,K)if F.parent==C then E.root=K elseif F==F.parent.left then F.parent.left=K else F.parent.right=K end;K.parent=F.parent end;local function L(F)while F.left~=C do F=F.left end;return F end;local function M(F)if F==C then return nil end;if F.parent==F then return nil end;if F.right~=C then return L(F.right)end;local N;while true do N=F.parent;if N==C then return nil end;if F==N.right then F=N else break end end;return N end;local function O(E,F)local N=C;local P=E.root;while P~=C do N=P;if F.key<P.key then P=P.left else P=P.right end end;F.parent=N;if N==C then E.root=F elseif F.key<N.key then N.left=F else N.right=F end;F.left=C;F.right=C;F.color=B;while F.parent.color==B do if F.parent==F.parent.parent.left then N=F.parent.parent.right;if N.color==B then F.parent.color=A;N.color=A;F.parent.parent.color=B;F=F.parent.parent else if F==F.parent.right then F=F.parent;D(E,F)end;F.parent.color=A;F.parent.parent.color=B;H(E,F.parent.parent)end else N=F.parent.parent.left;if N.color==B then F.parent.color=A;N.color=A;F.parent.parent.color=B;F=F.parent.parent else if F==F.parent.left then F=F.parent;H(E,F)end;F.parent.color=A;F.parent.parent.color=B;D(E,F.parent.parent)end end end;E.root.color=A end;local function Q(E,F)if F==C then return end;local R,S;local T=F.color;if F.left==C then R=F.right;J(E,F,F.right)elseif F.right==C then R=F.left;J(E,F,F.left)else local U=L(F.right)T=U.color;R=U.right;if U.parent==F then R.parent=U else J(E,U,U.right)U.right=F.right;U.right.parent=U end;J(E,F,U)U.left=F.left;U.left.parent=U;U.color=F.color end;if T~=A then return end;while R~=E.root and R.color==A do if R==R.parent.left then S=R.parent.right;if S.color==B then S.color=A;R.parent.color=B;D(E,R.parent)S=R.parent.right end;if S.left.color==A and S.right.color==A then S.color=B;R=R.parent else if S.right.color==A then S.left.color=A;S.color=B;H(E,S)S=R.parent.right end;S.color=R.parent.color;R.parent.color=A;S.right.color=A;D(E,R.parent)R=E.root end else S=R.parent.left;if S.color==B then S.color=A;R.parent.color=B;H(E,R.parent)S=R.parent.left end;if S.right.color==A and S.left.color==A then S.color=B;R=R.parent else if S.left.color==A then S.right.color=A;S.color=B;D(E,S)S=R.parent.left end;S.color=R.parent.color;R.parent.color=A;S.left.color=A;H(E,R.parent)R=E.root end end end;R.color=A end;local function V(E,W)local F=E.root;while F~=C and W~=F.key do if W<F.key then F=F.left else F=F.right end end;return F end;local function X(E)if E.root==C then return nil end;return L(E.root)end;local function Y(E,Z)local _={}local F=X(E)while F~=nil do if Z(F)then table.insert(_,F)end;F=M(F)end;return _ end;local function a0(E,a1)local F=X(E)while F~=nil do a1(F)F=M(F)end end;local function a2(E)local _={}local F=X(E)while F~=nil do table.insert(_,F)F=M(F)end;return _ end;local function a3()return{root=C,count=0}end;local function a4(W,a5)return{key=W,data=a5}end;local a6={}local a7=os.clock()local a8={}a8.__index=a8;function a8.get(w)local a9;a9,w=i(w)if a6[a9]==nil then a6[a9]=setmetatable({id=a9,components=w},a8)a7=os.clock()end;return a6[a9]end;function a8:with(aa)if table.find(self.components,aa)~=nil then return self end;local ab=table.getn(self.components)local ac=table.create(ab+1)ac[0]=aa;table.move(self.components,1,ab,2,ac)return a8.get(ac)end;function a8:without(aa)if table.find(self.components,aa)==nil then return self end;local ab=table.getn(self.components)local ac=table.create(ab-1)local ad=1;for ae=1,ab do if self.components[ae]~=aa then ac[ad]=self.components[ae]ad=ad+1 end end;return a8.get(ac)end;function a8:has(aa)return table.find(self.components,aa)~=nil end;local af=a8.get({})local ag={}local ah={}local ai={}local aj={}local ak={}local function al(am)return am end;local an={}local ao={register=function(ap,aq,ar,as)if ap==nil then error('Component name is required for registration')end;if aq~=nil and type(aq)~='function'then error('The component constructor must be a function, or nil')end;if aq==nil then aq=al end;if ar==nil then ar=false end;if as==nil then as=an end;if ak[ap]~=nil then error('Another component already registered with that name')end;local at=table.getn(ag)+1;ak[ap]=at;table.insert(ag,ap)table.insert(ai,as)table.insert(aj,ar)table.insert(ah,aq)return at end}local au=ao.register('_ECS_ENTITY_ID_')local av={}av.__index=av;local aw=300;function av.new(ax,ay)local az={}az[au]=table.create(aw)for g,aA in pairs(ay.components)do if aj[aA]then az[aA]=nil else az[aA]=table.create(aw)end end;return setmetatable({version=0,count=0,world=ax,archetype=ay,buffers=az},av)end;function av:clear(aB)local az=self.buffers;for aC in pairs(az)do az[aC][aB]=nil end end;function av:getValue(aB,aa)local az=self.buffers;if az[aa]==nil then return nil end;return az[aa][aB]end;function av:setValue(aB,aa,am)local az=self.buffers;if az[aa]==nil then return end;az[aa][aB]=am end;function av:get(aB)local a5={}local az=self.buffers;for aa in pairs(az)do a5[aa]=az[aa][aB]end;return a5 end;function av:set(aB,a5)local az=self.buffers;for aa,am in pairs(a5)do if az[aa]~=nil then az[aa][aB]=am end end end;function av:setEntityId(aB,aD)self.buffers[au][aB]=aD end;local aE={}aE.__index=aE;function aE.new(ax)return setmetatable({world=ax,version=0,COUNT=0,ENTITIES={},ARCHETYPES={}},aE)end;function aE:set(aF,ay)local aG=ay.id;local aD=self.ENTITIES[aF]local aH=nil;if aD~=nil then if aD.archetype==aG then return end;aH=self.ARCHETYPES[aD.archetype].chunks[aD.chunk]:get(aD.chunkIndex)self:remove(aF)end;if self.ARCHETYPES[aG]==nil then self.ARCHETYPES[aG]={count=0,lastChunk=1,nextChunkIndex=1,chunks={av.new(self.world,ay)}}self.version=self.version+1 end;local aI=self.ARCHETYPES[aG]self.ENTITIES[aF]={archetype=aG,chunk=aI.lastChunk,chunkIndex=aI.nextChunkIndex}self.COUNT=self.COUNT+1;local aJ=aI.chunks[aI.lastChunk]aJ:clear(aI.nextChunkIndex)if aH~=nil then aJ:set(aI.nextChunkIndex,aH)end;aJ:setEntityId(aI.nextChunkIndex,aF)aI.count=aI.count+1;aJ.count=aI.nextChunkIndex;aI.nextChunkIndex=aI.nextChunkIndex+1;aJ.version=self.world.version;if aI.nextChunkIndex>aw then aI.lastChunk=aI.lastChunk+1;aI.nextChunkIndex=1;aI.chunks[aI.lastChunk]=av.new(self.world,ay)self.version=self.version+1 end end;function aE:remove(aF)local aD=self.ENTITIES[aF]if aD==nil then return end;local aI=self.ARCHETYPES[aD.archetype]local aJ=aI.chunks[aD.chunk]aJ:clear(aD.chunkIndex)aJ.count=aJ.count-1;self.ENTITIES[aF]=nil;self.COUNT=self.COUNT-1;aI.count=aI.count-1;if aI.nextChunkIndex==1 then aI.chunks[aI.lastChunk]=nil;aI.lastChunk=aI.lastChunk-1;aI.nextChunkIndex=aw+1;self.version=self.version+1 end;if aI.count>0 then if aI.nextChunkIndex>1 then if not(aI.lastChunk==aD.chunk and aI.nextChunkIndex-1==aD.chunkIndex)then local aK=aI.chunks[aI.lastChunk]:get(aI.nextChunkIndex-1)aI.chunks[aD.chunk]:set(aD.chunkIndex,aK)local aL=aK[au]local aM=self.ENTITIES[aL]aM.chunk=aD.chunk;aM.chunkIndex=aD.chunkIndex end;aI.nextChunkIndex=aI.nextChunkIndex-1;aI.chunks[aI.lastChunk]:clear(aI.nextChunkIndex)end else aI.nextChunkIndex=aI.nextChunkIndex-1 end end;function aE:count()return self.COUNT end;function aE:clear(aF)local aD=self.ENTITIES[aF]if aD==nil then return end;local aJ=self.ARCHETYPES[aD.archetype].chunks[aD.chunk]aJ:clear(aD.chunkIndex)end;function aE:getValue(aF,aa)local aD=self.ENTITIES[aF]if aD==nil then return nil end;return self.ARCHETYPES[aD.archetype].chunks[aD.chunk]:getValue(aD.chunkIndex,aa)end;function aE:setValue(aF,aa,am)local aD=self.ENTITIES[aF]if aD==nil then return end;local aJ=self.ARCHETYPES[aD.archetype].chunks[aD.chunk]aJ:setValue(aD.chunkIndex,aa,am)end;function aE:getData(aF)local aD=self.ENTITIES[aF]if aD==nil then return nil end;local aJ=self.ARCHETYPES[aD.archetype].chunks[aD.chunk]return aJ:get(aD.chunkIndex)end;function aE:setData(aF,aa,a5)local aD=self.ENTITIES[aF]if aD==nil then return end;local aJ=self.ARCHETYPES[aD.archetype].chunks[aD.chunk]aJ:set(aD.chunkIndex,aa,a5)end;function aE:getEntityChunk(aF)local aD=self.ENTITIES[aF]if aD==nil then return end;return self.ARCHETYPES[aD.archetype].chunks[aD.chunk],aD.chunkIndex end;function aE:filterChunks(aN)local aO={}for aG,aI in pairs(self.ARCHETYPES)do if aN(a6[aG].components)then for ae,aJ in pairs(aI.chunks)do table.insert(aO,aJ)end end end;return aO end;local aP={}local aQ={}local aR={}function aR.register(m)if m==nil then error('System configuration is required for its creation')end;if m.name==nil then error('The system "name" is required for registration')end;if aQ[m.name]~=nil then error('Another System already registered with that name')end;local aS=l(m)if m.step==nil then m.step='transform'end;if m.step~='task'and m.step~='render'and m.step~='process'and m.step~='processIn'and m.step~='processOut'and m.step~='transform'then error('The "step" parameter must be "task", "render", "process", "transform", "processIn" or "processOut"')end;if m.step=='task'then if m.order~=nil then error('Task-type systems do not accept the "order" parameter')end;if m.update~=nil then error('Task-type systems do not accept the "update" parameter')end;if m.beforeUpdate~=nil then error('Task-type systems do not accept the "beforeUpdate" parameter')end;if m.afterUpdate~=nil then error('Task-type systems do not accept the "afterUpdate" parameter')end;if m.onEnter~=nil then error('Task-type systems do not accept the "onEnter" parameter')end;if m.execute==nil then error('The task "execute" method is required for registration')end end;if m.order==nil or m.order<0 then m.order=50 end;table.insert(aP,{name=m.name,filter=aS,requireAll=m.requireAll,requireAny=m.requireAny,requireAllOriginal=m.requireAllOriginal,requireAnyOriginal=m.requireAnyOriginal,rejectAll=m.rejectAll,rejectAny=m.rejectAny,beforeUpdate=m.beforeUpdate,afterUpdate=m.afterUpdate,update=m.update,onEnter=m.onEnter,onRemove=m.onRemove,beforeExecute=m.beforeExecute,execute=m.execute,step=m.step,order=m.order})local at=table.getn(aP)aQ[m.name]=at;return at end;local aT={}aT.__index=aT;local aU=0.008;local aV=0.002;function aT.new(ax,aW)return setmetatable({world=ax,entityManager=aW,min_vruntime=0,rbtree=a3(),lastEntityManagerVersion=-1,systems={}},aT)end;function aT:addSystem(aX,m)if self.systems[aX]~=nil then return end;if m==nil then m={}end;local aY={id=aX,name=aP[aX].name,requireAll=aP[aX].requireAll,requireAny=aP[aX].requireAny,requireAllOriginal=aP[aX].requireAllOriginal,requireAnyOriginal=aP[aX].requireAnyOriginal,rejectAll=aP[aX].rejectAll,rejectAny=aP[aX].rejectAny,filter=aP[aX].filter,beforeExecute=aP[aX].beforeExecute,execute=aP[aX].execute,config=m}self.systems[aX]=aY;self.lastEntityManagerVersion=0 end;function aT:run(aZ)if self.entityManager.version~=self.lastEntityManagerVersion then self:update()self.lastEntityManagerVersion=self.entityManager.version end;local E=self.rbtree;local ax=self.world;local a_=math.max(aU,0.01667-(os.clock()-aZ.frameReal)-aV)local b0={}local b1=os.clock()local b2,aJ,aY,b3,b4;local b5=X(E)while b5~=nil do Q(E,b5)aJ=b5.data[1]aY=b5.data[2]b3=b5.data[3]b4=b5.data[4]b2=os.clock()if b4==0 then b4=b2 end;local b6=aY.requireAllOriginal;if b6==nil then b6=aY.requireAnyOriginal end;local b7=table.getn(b6)local b8=aY.execute;ax.version=ax.version+1;if aY.beforeExecute~=nil then aY.beforeExecute(aZ,ax,aY)end;local b9=aJ.version==0 or aJ.version>b3;local az=aJ.buffers;local ba=az[au]local bb=table.create(b7)local bc=false;for bd,be in ipairs(b6)do if az[be]~=nil then bb[bd]=az[be]else bb[bd]={}end end;local bf={process=aZ.process,frame=aZ.frame,frameReal=aZ.frameReal,delta=aZ.delta,deltaExec=b2-b4}for aB=1,aJ.count do if b8(bf,ax,b9,ba[aB],aB,table.unpack(bb))then bc=true end end;if bc then aJ.version=ax.version end;b5.data[3]=ax.version;b5.data[4]=b2;b5.key=b5.key+os.clock()-b2;O(E,b5)if os.clock()-b1>a_ then break end;b5=M(b5)end;local bg=X(E)if bg~=nil then self.min_vruntime=math.max(bg.key-b,0)else self.min_vruntime=0 end end;function aT:update()local E=self.rbtree;local bh=self.systems;local aW=self.entityManager;local bi=self.min_vruntime;local bj=self.world.version;local bk={}local bl={}local aJ,aY;a0(E,function(b5)aJ=b5.data[1]aY=b5.data[2]if bk[aJ]==nil then bk[aJ]={}end;if bk[aJ][aY]==nil then bk[aJ][aY]={}end;table.insert(bk[aJ][aY],b5)bl[aJ]=true end)for ae,bm in pairs(bh)do local aO=aW:filterChunks(bm.filter.match)for bn,bo in pairs(aO)do bl[bo]=nil;if bk[bo]==nil then O(E,a4(bi,{bo,bm,bj,0}))elseif bk[bo][bm]==nil then O(E,a4(bi,{bo,bm,bj,0}))end end end;for bp,g in pairs(bl)do for bq,b0 in pairs(bk[bp])do for g,b5 in ipairs(b0)do Q(E,b5)end end end end;local function br(ax,bh)local bs={processIn={},process={},processOut={},transform={},render={}}local bt={processIn={},process={},processOut={},transform={},render={}}local bu={}local bv={}for aC,aY in pairs(bh)do if aY.update~=nil then if bs[aY.step][aY.order]==nil then bs[aY.step][aY.order]={}table.insert(bt[aY.step],aY.order)end;table.insert(bs[aY.step][aY.order],aY)end;if aY.onEnter~=nil then table.insert(bu,aY)end;if aY.onRemove~=nil then table.insert(bv,aY)end end;for g,bw in ipairs(bt)do table.sort(bw)end;local bx=function(by,aW,aZ,bz)local bA=bs[by]for ae,bw in pairs(bt[by])do for bn,aY in pairs(bA[bw])do aY.lastUpdate=aZ;local b6=aY.requireAllOriginal;if b6==nil then b6=aY.requireAnyOriginal end;local b7=table.getn(b6)local bB=aY.version;local aO=aW:filterChunks(aY.filter.match)local bC=aY.update;ax.version=ax.version+1;if aY.beforeUpdate~=nil then aY.beforeUpdate(aZ,bz,ax,aY)end;for aC,aJ in pairs(aO)do local b9=aJ.version==0 or aJ.version>bB;local az=aJ.buffers;local ba=az[au]local bb=table.create(b7)local bc=false;for bd,be in ipairs(b6)do if az[be]~=nil then bb[bd]=az[be]else bb[bd]={}end end;for aB=1,aJ.count do if bC(aZ,ax,b9,ba[aB],aB,table.unpack(bb))then bc=true end end;if bc then aJ.version=ax.version end end;if aY.afterUpdate~=nil then aY.afterUpdate(aZ,bz,ax,aY)end;aY.version=ax.version end end end;local bD=function(bE,aW,aZ)ax.version=ax.version+1;for aF,bF in pairs(bE)do local bG=l({requireAny=bF})local aJ,aB=aW:getEntityChunk(aF)if aJ~=nil then local az=aJ.buffers;for bn,aY in pairs(bu)do if aY.filter.match(aJ.archetype.components)then local b6=aY.requireAllOriginal;if b6==nil then b6=aY.requireAnyOriginal end;if bG.match(b6)then local bb=table.create(table.getn(b6))for bd,be in ipairs(b6)do if az[be]~=nil then bb[bd]=az[be]else bb[bd]={}end end;if aY.onEnter(aZ,ax,aF,aB,table.unpack(bb))then aJ.version=ax.version end end end end end end end;local bH=function(bI,aW,aZ)ax.version=ax.version+1;for aF,g in pairs(bI)do local aJ,aB=aW:getEntityChunk(aF)if aJ~=nil then local az=aJ.buffers;for g,aY in pairs(bv)do if aY.filter.match(aJ.archetype.components)then local b6=aY.requireAllOriginal;if b6==nil then b6=aY.requireAnyOriginal end;local bb=table.create(table.getn(b6))for bd,be in ipairs(b6)do if az[be]~=nil then bb[bd]=az[be]else bb[bd]={}end end;if aY.onRemove(aZ,ax,aF,aB,table.unpack(bb))then aJ.version=ax.version end end end end end end;return bx,bD,bH end;local bJ={Component=ao,System=aR,Filter=l}function bJ.newWorld(bh,m)if m==nil then m={}end;if m.frequency==nil then m.frequency=30 end;local bK=math.round(math.abs(m.frequency)/2)*2;if bK<2 then bK=2 end;if m.frequency~=bK then m.frequency=bK;print(string.format(">>> ATTENTION! The execution frequency of world has been changed to %d <<<",bK))end;local bL=1;local bM={}local bN;local bO,bP,bQ;local bR=1000/m.frequency/1000;local bz=1;local bS=nil;local bT=0;local bU=0;local bV=0;local bW=0;local bX=0;local bY=0;local bZ=10;local b_=0;local aW;local c0;local c1;local c2={}local c3={}local c4={}local c5={}local ax;local c6;local c7=false;ax={version=0,frequency=m.frequency,create=function()local at=bL;bL=bL+1;c0:set(at,af)c2[at]=true;c5[at]=af;c7=true;return at end,get=function(aD,aa)if c2[aD]==true then return c0:getValue(aD,aa)elseif c4[aD]~=nil then return c1:getValue(aD,aa)else return aW:getValue(aD,aa)end end,set=function(aD,aa,...)local ay=c5[aD]if ay==nil then return end;c7=true;local c8=ay:with(aa)local c9=ay~=c8;if c9 then c5[aD]=c8 end;local am;local ca={...}if ca and ca[1]and typeof(ca[1])=='table'and ca[1].__v then am=ca[1].__v[0]else am=ah[aa](table.unpack(ca))end;if c2[aD]==true then if c9 then c0:set(aD,c8)end;c0:setValue(aD,aa,am)else if c9 then if c4[aD]==nil then c4[aD]={received={},lost={}}c1:set(aD,c8)c1:setData(aD,aW:getData(aD))else c1:set(aD,c8)end end;if c4[aD]~=nil then c1:setValue(aD,aa,am)local cb=false;for aC,h in pairs(c4[aD].lost)do if h==aa then table.remove(c4[aD].lost,aC)cb=true;break end end;if not cb then table.insert(c4[aD].received,aa)end end;aW:setValue(aD,aa,am)end end,call=function(aD,aa,cc,...)local cd=ai[aa][cc]if not cd then return nil end;local ce,am=cd(ax.get(aD,aa),table.unpack({...}))if ce then ax.set(aD,aa,{__v={am}})end;return am end,remove=function(aD,aa)local ay=c5[aD]if ay==nil then return end;if c3[aD]==true then return end;c7=true;if aa==nil then if c2[aD]==true then c0:remove(aD)c2[aD]=nil;c5[aD]=nil else if c3[aD]==nil then c3[aD]=true end end else local c8=ay:without(aa)local c9=ay~=c8;if c9 then c5[aD]=c8 end;if c2[aD]==true then if c9 then c0:set(aD,c8)end else if c9 then if c4[aD]==nil then c4[aD]={received={},lost={}}c1:set(aD,c8)c1:setData(aD,aW:getData(aD))else c1:set(aD,c8)end end;if c4[aD]~=nil then c1:setValue(aD,aa,nil)local cb=false;for aC,h in pairs(c4[aD].received)do if h==aa then table.remove(c4[aD].received,aC)cb=true;break end end;if not cb then table.insert(c4[aD].lost,aa)end end;aW:setValue(aD,aa,nil)end end end,has=function(aD,aa)if c5[aD]==nil then return false end;return c5[aD]:has(aa)end,forEach=function(aS,a1)local cf=false;local cg=function()cf=true end;local aO=aW:filterChunks(aS.match)for aC,aJ in pairs(aO)do local az=aJ.buffers;local bb=table.create(table.getn(aS.components))for bd,be in ipairs(aS.components)do if az[be]~=nil then bb[bd]=az[be]else bb[bd]={}end end;local ba=az[au]local bc=false;for aB=1,aJ.count do if a1(cg,ba[aB],aB,table.unpack(bb))then bc=true end;if cf then break end end;if bc then aJ.version=ax.version end;if cf then break end end end,addSystem=function(aX,bw,m)if aX==nil then return end;if aP[aX]==nil then error('There is no registered system with the given ID')end;if aP[aX].step=='task'then bN:addSystem(aX)else if bM[aX]~=nil then return end;if aW:count()>0 or c0:count()>0 then error('Adding systems is not allowed after adding entities in the world')end;if m==nil then m={}end;local aY={id=aX,name=aP[aX].name,requireAll=aP[aX].requireAll,requireAny=aP[aX].requireAny,requireAllOriginal=aP[aX].requireAllOriginal,requireAnyOriginal=aP[aX].requireAnyOriginal,rejectAll=aP[aX].rejectAll,rejectAny=aP[aX].rejectAny,filter=aP[aX].filter,beforeUpdate=aP[aX].beforeUpdate,afterUpdate=aP[aX].afterUpdate,update=aP[aX].update,onEnter=aP[aX].onEnter,onRemove=aP[aX].onRemove,step=aP[aX].step,order=aP[aX].order,version=0,lastUpdate=bW,config=m}if bw~=nil and bw<0 then aY.order=50 end;bM[aX]=aY;b_=0 end end,alive=function(aD)if c5[aD]==nil then return false end;if c2[aD]==true then return false end;if c3[aD]==true then return false end;return true end,destroy=function()if ax._steppedConn~=nil then ax._steppedConn:Disconnect()ax._steppedConn=nil end;if ax._heartbeatConn~=nil then ax._heartbeatConn:Disconnect()ax._heartbeatConn=nil end;if ax._renderSteppedConn~=nil then ax._renderSteppedConn:Disconnect()ax._renderSteppedConn=nil end;aW=nil;c0=nil;c1=nil;c4=nil;c3=nil;bM=nil;bO=nil;bP=nil;bQ=nil;c6=nil;c5=nil;bN=nil;ax.create=nil;ax.set=nil;ax.get=nil;ax.remove=nil;ax.has=nil;ax.forEach=nil;ax.addSystem=nil;ax.alive=nil;ax.update=nil;ax.destroy=nil;ax=nil end,update=function(by,ch)if not a:IsRunning()then return end;if bS==nil then bS=ch end;local ci=ch;ch=ch-bS;if b_<a7 then bO,bP,bQ=br(ax,bM)b_=a7 end;if by~='process'then if bW~=bX then bz=1+(ch-bW)/bR else bz=1 end;if by=='processIn'then bU=ch;bV=ci;if bT==0 then bT=bU end;if bW==0 then bW=bU;bX=bU end;bY=bU-bT;bz=1 elseif by=='render'then bT=bU end;local aZ={process=bW,frame=bU,frameReal=bV,now=ch,nowReal=ci,delta=bY}bO(by,aW,aZ,bz)while c7 do c6(aZ)end;if by=='transform'then bN:run(aZ)c6(aZ)end else local cj=bW;local ck=0;local cl=false;while bW<bU and ck<bZ do cl=true;if b_<a7 then bO,bP=br(ax,bM)b_=a7 end;local aZ={process=bW,processDelta=bR,frame=bU,frameReal=bV,now=ch,nowReal=ci,delta=bY}bO(by,aW,aZ,1)while c7 do c6(aZ)end;ck=ck+1;bW=bW+bR end;if cl then bX=cj end end end}c6=function(aZ)if not c7 then return end;c7=false;local cm=false;local bE={}bQ(c3,aW,aZ)for aF,cn in pairs(c3)do aW:remove(aF)c5[aF]=nil;if c4[aF]~=nil then c4[aF]=nil;c1:remove(aF)end end;c3={}for aF,cl in pairs(c4)do aW:set(aF,c5[aF])aW:setData(aF,c1:getData(aF))c1:remove(aF)if table.getn(cl.received)>0 then bE[aF]=cl.received;cm=true end end;c4={}for aF,cn in pairs(c2)do aW:set(aF,c5[aF])aW:setData(aF,c0:getData(aF))c0:remove(aF)bE[aF]=c5[aF].components;cm=true end;c2={}if cm then bP(bE,aW,aZ)bE=nil end end;aW=aE.new(ax)c0=aE.new(ax)c1=aE.new(ax)bN=aT.new(ax,aW)if bh~=nil then for ae,aY in pairs(bh)do ax.addSystem(aY)end end;if not m.disableAutoUpdate then ax._steppedConn=a.Stepped:Connect(function()ax.update('processIn',os.clock())ax.update('process',os.clock())ax.update('processOut',os.clock())end)ax._heartbeatConn=a.Heartbeat:Connect(function()ax.update('transform',os.clock())end)ax._renderSteppedConn=a.RenderStepped:Connect(function()ax.update('render',os.clock())end)end;return ax end;return bJ