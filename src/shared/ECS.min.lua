--[[
	Roblox-ECS v1.1  [2020-11-19 02:13]

	Roblox-ECS is a tiny and easy to use ECS (Entity Component System) engine for
	game development on the Roblox platform

	This is a minified version of Roblox-ECS, to see the full source code visit
	https://github.com/nidorx/roblox-ecs

	Discussions about this script are at https://devforum.roblox.com/t/841175

	This code was minified using https://goonlinetools.com/lua-minifier/

	------------------------------------------------------------------------------

	MIT License

	Copyright (c) 2020 Alex Rodin

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.
]]
local a=game:GetService('RunService')local b=0.000000001;local function c(d)if d==nil then d={}end;local e={}local f={}for g,h in pairs(d)do if h~=nil and e[h]==nil then table.insert(f,h)e[h]=true end end;table.sort(f)return f end;local function i(j)j=c(j)return'_'..table.concat(j,'_'),j end;local k={}local function l(m)local n={}if m==nil then m={}end;if m.requireAll==nil and m.requireAny==nil then error('It is necessary to define the components using the "requireAll" or "requireAny" parameters')end;if m.requireAll~=nil and m.requireAny~=nil then error('It is not allowed to use the "requireAll" and "requireAny" settings simultaneously')end;if m.requireAll~=nil then m.requireAllOriginal=m.requireAll;m.requireAll=c(m.requireAll)if table.getn(m.requireAll)==0 then error('You must enter at least one component id in the "requireAll" field')end elseif m.requireAny~=nil then m.requireAnyOriginal=m.requireAny;m.requireAny=c(m.requireAny)if table.getn(m.requireAny)==0 then error('You must enter at least one component id in the "requireAny" field')end end;if m.rejectAll~=nil and m.rejectAny~=nil then error('It is not allowed to use the "rejectAll" and "rejectAny" settings simultaneously')end;if m.rejectAll~=nil then m.rejectAll=c(m.rejectAll)if table.getn(m.rejectAll)==0 then error('You must enter at least one component id in the "rejectAll" field')end elseif m.rejectAny~=nil then m.rejectAny=c(m.rejectAny)if table.getn(m.rejectAny)==0 then error('You must enter at least one component id in the "rejectAny" field')end end;local o,p=i(m.requireAll)local q,r=i(m.requireAny)local s,t=i(m.rejectAll)local u,v=i(m.rejectAny)local w=m.requireAllOriginal;if w==nil then w=m.requireAnyOriginal end;return{components=w,match=function(w)local x=n[w]if x==false then return false elseif x==true then return true else local y=k[w]if y==nil then y={matchAny={},matchAll={},rejectAny={},rejectAll={}}k[w]=y end;if u~='_'then if y.rejectAny[u]or y.rejectAll[u]then n[w]=false;return false end;for g,h in pairs(v)do if table.find(w,h)then n[w]=false;y.matchAny[u]=true;y.rejectAny[u]=true;return false end end end;if s~='_'then if y.rejectAll[s]then n[w]=false;return false end;local z=true;for g,h in pairs(t)do if not table.find(w,h)then z=false;break end end;if z then n[w]=false;y.matchAll[s]=true;y.rejectAll[s]=true;return false end end;if q~='_'then if y.matchAny[q]or y.matchAll[q]then n[w]=true;return true end;for g,h in pairs(r)do if table.find(w,h)then y.matchAny[q]=true;n[w]=true;return true end end end;if o~='_'then if y.matchAll[o]then n[w]=true;return true end;local z=true;for g,h in pairs(p)do if not table.find(w,h)then z=false;break end end;if z then n[w]=true;y.matchAll[o]=true;y.rejectAll[o]=true;return true end end;n[w]=false;return false end end}end;local A=0;local B=1;local C={key=0,color=A}local function D(E,F)local G=F.right;F.right=G.left;if G.left~=C then G.left.parent=F end;G.parent=F.parent;if F.parent==C then E.root=G elseif F==F.parent.left then F.parent.left=G else F.parent.right=G end;G.left=F;F.parent=G end;local function H(E,F)local I=F.left;F.left=I.right;if I.right~=C then I.right.parent=F end;I.parent=F.parent;if F.parent==C then E.root=I elseif F==F.parent.right then F.parent.right=I else F.parent.left=I end;I.right=F;F.parent=I end;local function J(E,F,K)if F.parent==C then E.root=K elseif F==F.parent.left then F.parent.left=K else F.parent.right=K end;K.parent=F.parent end;local function L(F)while F.left~=C do F=F.left end;return F end;local function M(F)if F==C then return nil end;if F.parent==F then return nil end;if F.right~=C then return L(F.right)end;local N;while true do N=F.parent;if N==C then return nil end;if F==N.right then F=N else break end end;return N end;local function O(E,F)local N=C;local P=E.root;while P~=C do N=P;if F.key<P.key then P=P.left else P=P.right end end;F.parent=N;if N==C then E.root=F elseif F.key<N.key then N.left=F else N.right=F end;F.left=C;F.right=C;F.color=B;while F.parent.color==B do if F.parent==F.parent.parent.left then N=F.parent.parent.right;if N.color==B then F.parent.color=A;N.color=A;F.parent.parent.color=B;F=F.parent.parent else if F==F.parent.right then F=F.parent;D(E,F)end;F.parent.color=A;F.parent.parent.color=B;H(E,F.parent.parent)end else N=F.parent.parent.left;if N.color==B then F.parent.color=A;N.color=A;F.parent.parent.color=B;F=F.parent.parent else if F==F.parent.left then F=F.parent;H(E,F)end;F.parent.color=A;F.parent.parent.color=B;D(E,F.parent.parent)end end end;E.root.color=A end;local function Q(E,F)if F==C then return end;local R,S;local T=F.color;if F.left==C then R=F.right;J(E,F,F.right)elseif F.right==C then R=F.left;J(E,F,F.left)else local U=L(F.right)T=U.color;R=U.right;if U.parent==F then R.parent=U else J(E,U,U.right)U.right=F.right;U.right.parent=U end;J(E,F,U)U.left=F.left;U.left.parent=U;U.color=F.color end;if T~=A then return end;while R~=E.root and R.color==A do if R==R.parent.left then S=R.parent.right;if S.color==B then S.color=A;R.parent.color=B;D(E,R.parent)S=R.parent.right end;if S.left.color==A and S.right.color==A then S.color=B;R=R.parent else if S.right.color==A then S.left.color=A;S.color=B;H(E,S)S=R.parent.right end;S.color=R.parent.color;R.parent.color=A;S.right.color=A;D(E,R.parent)R=E.root end else S=R.parent.left;if S.color==B then S.color=A;R.parent.color=B;H(E,R.parent)S=R.parent.left end;if S.right.color==A and S.left.color==A then S.color=B;R=R.parent else if S.left.color==A then S.right.color=A;S.color=B;D(E,S)S=R.parent.left end;S.color=R.parent.color;R.parent.color=A;S.left.color=A;H(E,R.parent)R=E.root end end end;R.color=A end;local function V(E,W)local F=E.root;while F~=C and W~=F.key do if W<F.key then F=F.left else F=F.right end end;return F end;local function X(E)if E.root==C then return nil end;return L(E.root)end;local function Y(E,Z)local _={}local F=X(E)while F~=nil do if Z(F)then table.insert(_,F)end;F=M(F)end;return _ end;local function a0(E,a1)local F=X(E)while F~=nil do a1(F)F=M(F)end end;local function a2(E)local _={}local F=X(E)while F~=nil do table.insert(_,F)F=M(F)end;return _ end;local function a3()return{root=C,count=0}end;local function a4(W,a5)return{key=W,data=a5}end;local a6={}local a7=os.clock()local a8={}a8.__index=a8;function a8.get(w)local a9;a9,w=i(w)if a6[a9]==nil then a6[a9]=setmetatable({id=a9,components=w},a8)a7=os.clock()end;return a6[a9]end;function a8:with(aa)if table.find(self.components,aa)~=nil then return self end;local ab=table.getn(self.components)local ac=table.create(ab+1)ac[0]=aa;table.move(self.components,1,ab,2,ac)return a8.get(ac)end;function a8:without(aa)if table.find(self.components,aa)==nil then return self end;local ab=table.getn(self.components)local ac=table.create(ab-1)local ad=1;for ae=1,ab do if self.components[ae]~=aa then ac[ad]=self.components[ae]ad=ad+1 end end;return a8.get(ac)end;function a8:has(aa)return table.find(self.components,aa)~=nil end;local af=a8.get({})local ag={}local ah={}local ai={}local aj={}local function ak(al)return al end;local am={register=function(an,ao,ap)if an==nil then error('Component name is required for registration')end;if ao~=nil and type(ao)~='function'then error('The component constructor must be a function, or nil')end;if ao==nil then ao=ak end;if ap==nil then ap=false end;if aj[an]~=nil then error('Another component already registered with that name')end;local aq=table.getn(ag)+1;aj[an]=aq;table.insert(ag,an)table.insert(ai,ap)table.insert(ah,ao)return aq end}local ar=am.register('_ECS_ENTITY_ID_')local as={}as.__index=as;local at=300;function as.new(au,av)local aw={}aw[ar]=table.create(at)for g,ax in pairs(av.components)do if ai[ax]then aw[ax]=nil else aw[ax]=table.create(at)end end;return setmetatable({version=0,count=0,world=au,archetype=av,buffers=aw},as)end;function as:clear(ay)local aw=self.buffers;for az in pairs(aw)do aw[az][ay]=nil end end;function as:getValue(ay,aa)local aw=self.buffers;if aw[aa]==nil then return nil end;return aw[aa][ay]end;function as:setValue(ay,aa,al)local aw=self.buffers;if aw[aa]==nil then return end;aw[aa][ay]=al end;function as:get(ay)local a5={}local aw=self.buffers;for aa in pairs(aw)do a5[aa]=aw[aa][ay]end;return a5 end;function as:set(ay,a5)local aw=self.buffers;for aa,al in pairs(a5)do if aw[aa]~=nil then aw[aa][ay]=al end end end;function as:setEntityId(ay,aA)self.buffers[ar][ay]=aA end;local aB={}aB.__index=aB;function aB.new(au)return setmetatable({world=au,version=0,COUNT=0,ENTITIES={},ARCHETYPES={}},aB)end;function aB:set(aC,av)local aD=av.id;local aA=self.ENTITIES[aC]local aE=nil;if aA~=nil then if aA.archetype==aD then return end;aE=self.ARCHETYPES[aA.archetype].chunks[aA.chunk]:get(aA.chunkIndex)self:remove(aC)end;if self.ARCHETYPES[aD]==nil then self.ARCHETYPES[aD]={count=0,lastChunk=1,nextChunkIndex=1,chunks={as.new(self.world,av)}}self.version=self.version+1 end;local aF=self.ARCHETYPES[aD]self.ENTITIES[aC]={archetype=aD,chunk=aF.lastChunk,chunkIndex=aF.nextChunkIndex}self.COUNT=self.COUNT+1;local aG=aF.chunks[aF.lastChunk]aG:clear(aF.nextChunkIndex)if aE~=nil then aG:set(aF.nextChunkIndex,aE)end;aG:setEntityId(aF.nextChunkIndex,aC)aF.count=aF.count+1;aG.count=aF.nextChunkIndex;aF.nextChunkIndex=aF.nextChunkIndex+1;aG.version=self.world.version;if aF.nextChunkIndex>at then aF.lastChunk=aF.lastChunk+1;aF.nextChunkIndex=1;aF.chunks[aF.lastChunk]=as.new(self.world,av)self.version=self.version+1 end end;function aB:remove(aC)local aA=self.ENTITIES[aC]if aA==nil then return end;local aF=self.ARCHETYPES[aA.archetype]local aG=aF.chunks[aA.chunk]aG:clear(aA.chunkIndex)aG.count=aG.count-1;self.ENTITIES[aC]=nil;self.COUNT=self.COUNT-1;aF.count=aF.count-1;if aF.nextChunkIndex==1 then aF.chunks[aF.lastChunk]=nil;aF.lastChunk=aF.lastChunk-1;aF.nextChunkIndex=at+1;self.version=self.version+1 end;if aF.count>0 then if aF.nextChunkIndex>1 then if not(aF.lastChunk==aA.chunk and aF.nextChunkIndex-1==aA.chunkIndex)then local aH=aF.chunks[aF.lastChunk]:get(aF.nextChunkIndex-1)aF.chunks[aA.chunk]:set(aA.chunkIndex,aH)local aI=aH[ar]local aJ=self.ENTITIES[aI]aJ.chunk=aA.chunk;aJ.chunkIndex=aA.chunkIndex end;aF.nextChunkIndex=aF.nextChunkIndex-1;aF.chunks[aF.lastChunk]:clear(aF.nextChunkIndex)end else aF.nextChunkIndex=aF.nextChunkIndex-1 end end;function aB:count()return self.COUNT end;function aB:clear(aC)local aA=self.ENTITIES[aC]if aA==nil then return end;local aG=self.ARCHETYPES[aA.archetype].chunks[aA.chunk]aG:clear(aA.chunkIndex)end;function aB:getValue(aC,aa)local aA=self.ENTITIES[aC]if aA==nil then return nil end;return self.ARCHETYPES[aA.archetype].chunks[aA.chunk]:getValue(aA.chunkIndex,aa)end;function aB:setValue(aC,aa,al)local aA=self.ENTITIES[aC]if aA==nil then return end;local aG=self.ARCHETYPES[aA.archetype].chunks[aA.chunk]aG:setValue(aA.chunkIndex,aa,al)end;function aB:getData(aC)local aA=self.ENTITIES[aC]if aA==nil then return nil end;local aG=self.ARCHETYPES[aA.archetype].chunks[aA.chunk]return aG:get(aA.chunkIndex)end;function aB:setData(aC,aa,a5)local aA=self.ENTITIES[aC]if aA==nil then return end;local aG=self.ARCHETYPES[aA.archetype].chunks[aA.chunk]aG:set(aA.chunkIndex,aa,a5)end;function aB:getEntityChunk(aC)local aA=self.ENTITIES[aC]if aA==nil then return end;return self.ARCHETYPES[aA.archetype].chunks[aA.chunk],aA.chunkIndex end;function aB:filterChunks(aK)local aL={}for aD,aF in pairs(self.ARCHETYPES)do if aK(a6[aD].components)then for ae,aG in pairs(aF.chunks)do table.insert(aL,aG)end end end;return aL end;local aM={}local aN={}local aO={}function aO.register(m)if m==nil then error('System configuration is required for its creation')end;if m.name==nil then error('The system "name" is required for registration')end;if aN[m.name]~=nil then error('Another System already registered with that name')end;local aP=l(m)if m.step==nil then m.step='transform'end;if m.step~='task'and m.step~='render'and m.step~='process'and m.step~='processIn'and m.step~='processOut'and m.step~='transform'then error('The "step" parameter must be "task", "render", "process", "transform", "processIn" or "processOut"')end;if m.step=='task'then if m.order~=nil then error('Task-type systems do not accept the "order" parameter')end;if m.update~=nil then error('Task-type systems do not accept the "update" parameter')end;if m.beforeUpdate~=nil then error('Task-type systems do not accept the "beforeUpdate" parameter')end;if m.afterUpdate~=nil then error('Task-type systems do not accept the "afterUpdate" parameter')end;if m.onEnter~=nil then error('Task-type systems do not accept the "onEnter" parameter')end;if m.execute==nil then error('The task "execute" method is required for registration')end end;if m.order==nil or m.order<0 then m.order=50 end;table.insert(aM,{name=m.name,filter=aP,requireAll=m.requireAll,requireAny=m.requireAny,requireAllOriginal=m.requireAllOriginal,requireAnyOriginal=m.requireAnyOriginal,rejectAll=m.rejectAll,rejectAny=m.rejectAny,beforeUpdate=m.beforeUpdate,afterUpdate=m.afterUpdate,update=m.update,onEnter=m.onEnter,onRemove=m.onRemove,beforeExecute=m.beforeExecute,execute=m.execute,step=m.step,order=m.order})local aq=table.getn(aM)aN[m.name]=aq;return aq end;local aQ={}aQ.__index=aQ;local aR=0.008;local aS=0.002;function aQ.new(au,aT)return setmetatable({world=au,entityManager=aT,min_vruntime=0,rbtree=a3(),lastEntityManagerVersion=-1,systems={}},aQ)end;function aQ:addSystem(aU,m)if self.systems[aU]~=nil then return end;if m==nil then m={}end;local aV={id=aU,name=aM[aU].name,requireAll=aM[aU].requireAll,requireAny=aM[aU].requireAny,requireAllOriginal=aM[aU].requireAllOriginal,requireAnyOriginal=aM[aU].requireAnyOriginal,rejectAll=aM[aU].rejectAll,rejectAny=aM[aU].rejectAny,filter=aM[aU].filter,beforeExecute=aM[aU].beforeExecute,execute=aM[aU].execute,config=m}self.systems[aU]=aV;self.lastEntityManagerVersion=0 end;function aQ:run(aW)if self.entityManager.version~=self.lastEntityManagerVersion then self:update()self.lastEntityManagerVersion=self.entityManager.version end;local E=self.rbtree;local au=self.world;local aX=math.max(aR,0.01667-(os.clock()-aW.frameReal)-aS)local aY={}local aZ=os.clock()local a_,aG,aV,b0,b1;local b2=X(E)while b2~=nil do Q(E,b2)aG=b2.data[1]aV=b2.data[2]b0=b2.data[3]b1=b2.data[4]a_=os.clock()if b1==0 then b1=a_ end;local b3=aV.requireAllOriginal;if b3==nil then b3=aV.requireAnyOriginal end;local b4=table.getn(b3)local b5=aV.execute;au.version=au.version+1;if aV.beforeExecute~=nil then aV.beforeExecute(aW,au,aV)end;local b6=aG.version==0 or aG.version>b0;local aw=aG.buffers;local b7=aw[ar]local b8=table.create(b4)local b9=false;for ba,bb in ipairs(b3)do if aw[bb]~=nil then b8[ba]=aw[bb]else b8[ba]={}end end;local bc={process=aW.process,frame=aW.frame,frameReal=aW.frameReal,delta=aW.delta,deltaExec=a_-b1}for ay=1,aG.count do if b5(bc,au,b6,b7[ay],ay,table.unpack(b8))then b9=true end end;if b9 then aG.version=au.version end;b2.data[3]=au.version;b2.data[4]=a_;b2.key=b2.key+os.clock()-a_;O(E,b2)if os.clock()-aZ>aX then break end;b2=M(b2)end;local bd=X(E)if bd~=nil then self.min_vruntime=math.max(bd.key-b,0)else self.min_vruntime=0 end end;function aQ:update()local E=self.rbtree;local be=self.systems;local aT=self.entityManager;local bf=self.min_vruntime;local bg=self.world.version;local bh={}local bi={}local aG,aV;a0(E,function(b2)aG=b2.data[1]aV=b2.data[2]if bh[aG]==nil then bh[aG]={}end;if bh[aG][aV]==nil then bh[aG][aV]={}end;table.insert(bh[aG][aV],b2)bi[aG]=true end)for ae,bj in pairs(be)do local aL=aT:filterChunks(bj.filter.match)for bk,bl in pairs(aL)do bi[bl]=nil;if bh[bl]==nil then O(E,a4(bf,{bl,bj,bg,0}))elseif bh[bl][bj]==nil then O(E,a4(bf,{bl,bj,bg,0}))end end end;for bm,g in pairs(bi)do for bn,aY in pairs(bh[bm])do for g,b2 in ipairs(aY)do Q(E,b2)end end end end;local function bo(au,be)local bp={processIn={},process={},processOut={},transform={},render={}}local bq={processIn={},process={},processOut={},transform={},render={}}local br={}local bs={}for az,aV in pairs(be)do if aV.update~=nil then if bp[aV.step][aV.order]==nil then bp[aV.step][aV.order]={}table.insert(bq[aV.step],aV.order)end;table.insert(bp[aV.step][aV.order],aV)end;if aV.onEnter~=nil then table.insert(br,aV)end;if aV.onRemove~=nil then table.insert(bs,aV)end end;for g,bt in ipairs(bq)do table.sort(bt)end;local bu=function(bv,aT,aW,bw)local bx=bp[bv]for ae,bt in pairs(bq[bv])do for bk,aV in pairs(bx[bt])do aV.lastUpdate=aW;local b3=aV.requireAllOriginal;if b3==nil then b3=aV.requireAnyOriginal end;local b4=table.getn(b3)local by=aV.version;local aL=aT:filterChunks(aV.filter.match)local bz=aV.update;au.version=au.version+1;if aV.beforeUpdate~=nil then aV.beforeUpdate(aW,bw,au,aV)end;for az,aG in pairs(aL)do local b6=aG.version==0 or aG.version>by;local aw=aG.buffers;local b7=aw[ar]local b8=table.create(b4)local b9=false;for ba,bb in ipairs(b3)do if aw[bb]~=nil then b8[ba]=aw[bb]else b8[ba]={}end end;for ay=1,aG.count do if bz(aW,au,b6,b7[ay],ay,table.unpack(b8))then b9=true end end;if b9 then aG.version=au.version end end;if aV.afterUpdate~=nil then aV.afterUpdate(aW,bw,au,aV)end;aV.version=au.version end end end;local bA=function(bB,aT,aW)au.version=au.version+1;for aC,bC in pairs(bB)do local bD=l({requireAny=bC})local aG,ay=aT:getEntityChunk(aC)if aG~=nil then local aw=aG.buffers;for bk,aV in pairs(br)do if aV.filter.match(aG.archetype.components)then local b3=aV.requireAllOriginal;if b3==nil then b3=aV.requireAnyOriginal end;if bD.match(b3)then local b8=table.create(table.getn(b3))for ba,bb in ipairs(b3)do if aw[bb]~=nil then b8[ba]=aw[bb]else b8[ba]={}end end;if aV.onEnter(aW,au,aC,ay,table.unpack(b8))then aG.version=au.version end end end end end end end;local bE=function(bF,aT,aW)au.version=au.version+1;for aC,g in pairs(bF)do local aG,ay=aT:getEntityChunk(aC)if aG~=nil then local aw=aG.buffers;for g,aV in pairs(bs)do if aV.filter.match(aG.archetype.components)then local b3=aV.requireAllOriginal;if b3==nil then b3=aV.requireAnyOriginal end;local b8=table.create(table.getn(b3))for ba,bb in ipairs(b3)do if aw[bb]~=nil then b8[ba]=aw[bb]else b8[ba]={}end end;if aV.onRemove(aW,au,aC,ay,table.unpack(b8))then aG.version=au.version end end end end end end;return bu,bA,bE end;local bG={Component=am,System=aO,Filter=l}function bG.newWorld(be,m)if m==nil then m={}end;if m.frequency==nil then m.frequency=30 end;local bH=math.round(math.abs(m.frequency)/2)*2;if bH<2 then bH=2 end;if m.frequency~=bH then m.frequency=bH;print(string.format(">>> ATTENTION! The execution frequency of world has been changed to %d <<<",bH))end;local bI=1;local bJ={}local bK;local bL,bM,bN;local bO=1000/m.frequency/1000;local bw=1;local bP=nil;local bQ=0;local bR=0;local bS=0;local bT=0;local bU=0;local bV=0;local bW=10;local bX=0;local aT;local bY;local bZ;local b_={}local c0={}local c1={}local c2={}local au;local c3;local c4=false;au={version=0,frequency=m.frequency,create=function()local aq=bI;bI=bI+1;bY:set(aq,af)b_[aq]=true;c2[aq]=af;c4=true;return aq end,get=function(aA,aa)if b_[aA]==true then return bY:getValue(aA,aa)elseif c1[aA]~=nil then return bZ:getValue(aA,aa)else return aT:getValue(aA,aa)end end,set=function(aA,aa,...)local av=c2[aA]if av==nil then return end;c4=true;local c5=av:with(aa)local c6=av~=c5;if c6 then c2[aA]=c5 end;local al=ah[aa](table.unpack({...}))if b_[aA]==true then if c6 then bY:set(aA,c5)end;bY:setValue(aA,aa,al)else if c6 then if c1[aA]==nil then c1[aA]={received={},lost={}}bZ:set(aA,c5)bZ:setData(aA,aT:getData(aA))else bZ:set(aA,c5)end end;if c1[aA]~=nil then bZ:setValue(aA,aa,al)local c7=false;for az,h in pairs(c1[aA].lost)do if h==aa then table.remove(c1[aA].lost,az)c7=true;break end end;if not c7 then table.insert(c1[aA].received,aa)end end;aT:setValue(aA,aa,al)end end,remove=function(aA,aa)local av=c2[aA]if av==nil then return end;if c0[aA]==true then return end;c4=true;if aa==nil then if b_[aA]==true then bY:remove(aA)b_[aA]=nil;c2[aA]=nil else if c0[aA]==nil then c0[aA]=true end end else local c5=av:without(aa)local c6=av~=c5;if c6 then c2[aA]=c5 end;if b_[aA]==true then if c6 then bY:set(aA,c5)end else if c6 then if c1[aA]==nil then c1[aA]={received={},lost={}}bZ:set(aA,c5)bZ:setData(aA,aT:getData(aA))else bZ:set(aA,c5)end end;if c1[aA]~=nil then bZ:setValue(aA,aa,nil)local c7=false;for az,h in pairs(c1[aA].received)do if h==aa then table.remove(c1[aA].received,az)c7=true;break end end;if not c7 then table.insert(c1[aA].lost,aa)end end;aT:setValue(aA,aa,nil)end end end,has=function(aA,aa)if c2[aA]==nil then return false end;return c2[aA]:has(aa)end,forEach=function(aP,a1)local c8=false;local c9=function()c8=true end;local aL=aT:filterChunks(aP.match)for az,aG in pairs(aL)do local aw=aG.buffers;local b8=table.create(table.getn(aP.components))for ba,bb in ipairs(aP.components)do if aw[bb]~=nil then b8[ba]=aw[bb]else b8[ba]={}end end;local b7=aw[ar]local b9=false;for ay=1,aG.count do if a1(c9,b7[ay],ay,table.unpack(b8))then b9=true end;if c8 then break end end;if b9 then aG.version=au.version end;if c8 then break end end end,addSystem=function(aU,bt,m)if aU==nil then return end;if aM[aU]==nil then error('There is no registered system with the given ID')end;if aM[aU].step=='task'then bK:addSystem(aU)else if bJ[aU]~=nil then return end;if aT:count()>0 or bY:count()>0 then error('Adding systems is not allowed after adding entities in the world')end;if m==nil then m={}end;local aV={id=aU,name=aM[aU].name,requireAll=aM[aU].requireAll,requireAny=aM[aU].requireAny,requireAllOriginal=aM[aU].requireAllOriginal,requireAnyOriginal=aM[aU].requireAnyOriginal,rejectAll=aM[aU].rejectAll,rejectAny=aM[aU].rejectAny,filter=aM[aU].filter,beforeUpdate=aM[aU].beforeUpdate,afterUpdate=aM[aU].afterUpdate,update=aM[aU].update,onEnter=aM[aU].onEnter,onRemove=aM[aU].onRemove,step=aM[aU].step,order=aM[aU].order,version=0,lastUpdate=bT,config=m}if bt~=nil and bt<0 then aV.order=50 end;bJ[aU]=aV;bX=0 end end,alive=function(aA)if c2[aA]==nil then return false end;if b_[aA]==true then return false end;if c0[aA]==true then return false end;return true end,destroy=function()if au._steppedConn~=nil then au._steppedConn:Disconnect()au._steppedConn=nil end;if au._heartbeatConn~=nil then au._heartbeatConn:Disconnect()au._heartbeatConn=nil end;if au._renderSteppedConn~=nil then au._renderSteppedConn:Disconnect()au._renderSteppedConn=nil end;aT=nil;bY=nil;bZ=nil;c1=nil;c0=nil;bJ=nil;bL=nil;bM=nil;bN=nil;c3=nil;c2=nil;bK=nil;au.create=nil;au.set=nil;au.get=nil;au.remove=nil;au.has=nil;au.forEach=nil;au.addSystem=nil;au.alive=nil;au.update=nil;au.destroy=nil;au=nil end,update=function(bv,ca)if not a:IsRunning()then return end;if bP==nil then bP=ca end;local cb=ca;ca=ca-bP;if bX<a7 then bL,bM,bN=bo(au,bJ)bX=a7 end;if bv~='process'then if bT~=bU then bw=1+(ca-bT)/bO else bw=1 end;if bv=='processIn'then bR=ca;bS=cb;if bQ==0 then bQ=bR end;if bT==0 then bT=bR;bU=bR end;bV=bR-bQ;bw=1 elseif bv=='render'then bQ=bR end;local aW={process=bT,frame=bR,frameReal=bS,now=ca,nowReal=cb,delta=bV}bL(bv,aT,aW,bw)while c4 do c3(aW)end;if bv=='transform'then bK:run(aW)c3(aW)end else local cc=bT;local cd=0;local ce=false;while bT<bR and cd<bW do ce=true;if bX<a7 then bL,bM=bo(au,bJ)bX=a7 end;local aW={process=bT,processDelta=bO,frame=bR,frameReal=bS,now=ca,nowReal=cb,delta=bV}bL(bv,aT,aW,1)while c4 do c3(aW)end;cd=cd+1;bT=bT+bO end;if ce then bU=cc end end end}c3=function(aW)if not c4 then return end;c4=false;local cf=false;local bB={}bN(c0,aT,aW)for aC,cg in pairs(c0)do aT:remove(aC)c2[aC]=nil;if c1[aC]~=nil then c1[aC]=nil;bZ:remove(aC)end end;c0={}for aC,ce in pairs(c1)do aT:set(aC,c2[aC])aT:setData(aC,bZ:getData(aC))bZ:remove(aC)if table.getn(ce.received)>0 then bB[aC]=ce.received;cf=true end end;c1={}for aC,cg in pairs(b_)do aT:set(aC,c2[aC])aT:setData(aC,bY:getData(aC))bY:remove(aC)bB[aC]=c2[aC].components;cf=true end;b_={}if cf then bM(bB,aT,aW)bB=nil end end;aT=aB.new(au)bY=aB.new(au)bZ=aB.new(au)bK=aQ.new(au,aT)if be~=nil then for ae,aV in pairs(be)do au.addSystem(aV)end end;if not m.disableAutoUpdate then au._steppedConn=a.Stepped:Connect(function()au.update('processIn',os.clock())au.update('process',os.clock())au.update('processOut',os.clock())end)au._heartbeatConn=a.Heartbeat:Connect(function()au.update('transform',os.clock())end)au._renderSteppedConn=a.RenderStepped:Connect(function()au.update('render',os.clock())end)end;return au end;return bG