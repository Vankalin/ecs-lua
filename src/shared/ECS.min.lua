--[[
	Roblox-ECS v1.2

	Roblox-ECS is a tiny and easy to use ECS (Entity Component System) engine for
	game development on the Roblox platform

	This is a minified version of Roblox-ECS, to see the full source code visit
	https://github.com/nidorx/roblox-ecs

	Discussions about this script are at https://devforum.roblox.com/t/841175

	This code was minified using https://goonlinetools.com/lua-minifier/

	------------------------------------------------------------------------------

	MIT License

	Copyright (c) 2020 Alex Rodin

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.
]]
local a=game:GetService('RunService')local function b()return DateTime.now().UnixTimestampMillis end;local c={}local d={}local function e(f)local g=c[f]if g~=nil then if g+1000<b()then print(d[f],' times > ',f)c[f]=b()d[f]=0;return end;d[f]=d[f]+1 else c[f]=b()d[f]=1 end end;local h=0.000000001;local function i(j,k)if j==k then return true end;return math.abs(k-j)<h end;local function l(m,n)if m==n then return true end;if not i(m.X,n.X)or not i(m.Y,n.Y)or not i(m.Z,n.Z)then return false else return true end end;local function o(p)if p==nil then p={}end;local q={}local r={}for s,t in pairs(p)do if t~=nil and q[t]==nil then table.insert(r,t)q[t]=true end end;table.sort(r)return r end;local function u(v)v=o(v)return'_'..table.concat(v,'_'),v end;local w={}local function x(y)local z={}if y==nil then y={}end;if y.requireAll==nil and y.requireAny==nil then error('It is necessary to define the components using the "requireAll" or "requireAny" parameters')end;if y.requireAll~=nil and y.requireAny~=nil then error('It is not allowed to use the "requireAll" and "requireAny" settings simultaneously')end;if y.requireAll~=nil then y.requireAllOriginal=y.requireAll;y.requireAll=o(y.requireAll)if table.getn(y.requireAll)==0 then error('You must enter at least one component id in the "requireAll" field')end elseif y.requireAny~=nil then y.requireAnyOriginal=y.requireAny;y.requireAny=o(y.requireAny)if table.getn(y.requireAny)==0 then error('You must enter at least one component id in the "requireAny" field')end end;if y.rejectAll~=nil and y.rejectAny~=nil then error('It is not allowed to use the "rejectAll" and "rejectAny" settings simultaneously')end;if y.rejectAll~=nil then y.rejectAll=o(y.rejectAll)if table.getn(y.rejectAll)==0 then error('You must enter at least one component id in the "rejectAll" field')end elseif y.rejectAny~=nil then y.rejectAny=o(y.rejectAny)if table.getn(y.rejectAny)==0 then error('You must enter at least one component id in the "rejectAny" field')end end;local A,B=u(y.requireAll)local C,D=u(y.requireAny)local E,F=u(y.rejectAll)local G,H=u(y.rejectAny)local I=y.requireAllOriginal;if I==nil then I=y.requireAnyOriginal end;return{components=I,match=function(I)local J=z[I]if J==false then return false elseif J==true then return true else local K=w[I]if K==nil then K={matchAny={},matchAll={},rejectAny={},rejectAll={}}w[I]=K end;if G~='_'then if K.rejectAny[G]or K.rejectAll[G]then z[I]=false;return false end;for s,t in pairs(H)do if table.find(I,t)then z[I]=false;K.matchAny[G]=true;K.rejectAny[G]=true;return false end end end;if E~='_'then if K.rejectAll[E]then z[I]=false;return false end;local L=true;for s,t in pairs(F)do if not table.find(I,t)then L=false;break end end;if L then z[I]=false;K.matchAll[E]=true;K.rejectAll[E]=true;return false end end;if C~='_'then if K.matchAny[C]or K.matchAll[C]then z[I]=true;return true end;for s,t in pairs(D)do if table.find(I,t)then K.matchAny[C]=true;z[I]=true;return true end end end;if A~='_'then if K.matchAll[A]then z[I]=true;return true end;local L=true;for s,t in pairs(B)do if not table.find(I,t)then L=false;break end end;if L then z[I]=true;K.matchAll[A]=true;K.rejectAll[A]=true;return true end end;z[I]=false;return false end end}end;local M=0;local N=1;local O={key=0,color=M}local function P(Q,R)local S=R.right;R.right=S.left;if S.left~=O then S.left.parent=R end;S.parent=R.parent;if R.parent==O then Q.root=S elseif R==R.parent.left then R.parent.left=S else R.parent.right=S end;S.left=R;R.parent=S end;local function T(Q,R)local U=R.left;R.left=U.right;if U.right~=O then U.right.parent=R end;U.parent=R.parent;if R.parent==O then Q.root=U elseif R==R.parent.right then R.parent.right=U else R.parent.left=U end;U.right=R;R.parent=U end;local function V(Q,R,W)if R.parent==O then Q.root=W elseif R==R.parent.left then R.parent.left=W else R.parent.right=W end;W.parent=R.parent end;local function X(R)while R.left~=O do R=R.left end;return R end;local function Y(R)if R==O then return nil end;if R.parent==R then return nil end;if R.right~=O then return X(R.right)end;local Z;while true do Z=R.parent;if Z==O then return nil end;if R==Z.right then R=Z else break end end;return Z end;local function _(Q,R)local Z=O;local a0=Q.root;while a0~=O do Z=a0;if R.key<a0.key then a0=a0.left else a0=a0.right end end;R.parent=Z;if Z==O then Q.root=R elseif R.key<Z.key then Z.left=R else Z.right=R end;R.left=O;R.right=O;R.color=N;while R.parent.color==N do if R.parent==R.parent.parent.left then Z=R.parent.parent.right;if Z.color==N then R.parent.color=M;Z.color=M;R.parent.parent.color=N;R=R.parent.parent else if R==R.parent.right then R=R.parent;P(Q,R)end;R.parent.color=M;R.parent.parent.color=N;T(Q,R.parent.parent)end else Z=R.parent.parent.left;if Z.color==N then R.parent.color=M;Z.color=M;R.parent.parent.color=N;R=R.parent.parent else if R==R.parent.left then R=R.parent;T(Q,R)end;R.parent.color=M;R.parent.parent.color=N;P(Q,R.parent.parent)end end end;Q.root.color=M end;local function a1(Q,R)if R==O then return end;local a2,a3;local a4=R.color;if R.left==O then a2=R.right;V(Q,R,R.right)elseif R.right==O then a2=R.left;V(Q,R,R.left)else local a5=X(R.right)a4=a5.color;a2=a5.right;if a5.parent==R then a2.parent=a5 else V(Q,a5,a5.right)a5.right=R.right;a5.right.parent=a5 end;V(Q,R,a5)a5.left=R.left;a5.left.parent=a5;a5.color=R.color end;if a4~=M then return end;while a2~=Q.root and a2.color==M do if a2==a2.parent.left then a3=a2.parent.right;if a3.color==N then a3.color=M;a2.parent.color=N;P(Q,a2.parent)a3=a2.parent.right end;if a3.left.color==M and a3.right.color==M then a3.color=N;a2=a2.parent else if a3.right.color==M then a3.left.color=M;a3.color=N;T(Q,a3)a3=a2.parent.right end;a3.color=a2.parent.color;a2.parent.color=M;a3.right.color=M;P(Q,a2.parent)a2=Q.root end else a3=a2.parent.left;if a3.color==N then a3.color=M;a2.parent.color=N;T(Q,a2.parent)a3=a2.parent.left end;if a3.right.color==M and a3.left.color==M then a3.color=N;a2=a2.parent else if a3.left.color==M then a3.right.color=M;a3.color=N;P(Q,a3)a3=a2.parent.left end;a3.color=a2.parent.color;a2.parent.color=M;a3.left.color=M;T(Q,a2.parent)a2=Q.root end end end;a2.color=M end;local function a6(Q,a7)local R=Q.root;while R~=O and a7~=R.key do if a7<R.key then R=R.left else R=R.right end end;return R end;local function a8(Q)if Q.root==O then return nil end;return X(Q.root)end;local function a9(Q,aa)local ab={}local R=a8(Q)while R~=nil do if aa(R)then table.insert(ab,R)end;R=Y(R)end;return ab end;local function ac(Q,ad)local R=a8(Q)while R~=nil do ad(R)R=Y(R)end end;local function ae(Q)local ab={}local R=a8(Q)while R~=nil do table.insert(ab,R)R=Y(R)end;return ab end;local function af()return{root=O,count=0}end;local function ag(a7,ah)return{key=a7,data=ah}end;local ai={}local aj=b()local ak={}ak.__index=ak;function ak.get(I)local al;al,I=u(I)if ai[al]==nil then ai[al]=setmetatable({id=al,components=I},ak)aj=b()end;return ai[al]end;function ak:with(am)if table.find(self.components,am)~=nil then return self end;local an=table.getn(self.components)local ao=table.create(an+1)ao[0]=am;table.move(self.components,1,an,2,ao)return ak.get(ao)end;function ak:without(am)if table.find(self.components,am)==nil then return self end;local an=table.getn(self.components)local ao=table.create(an-1)local ap=1;for aq=1,an do if self.components[aq]~=am then ao[ap]=self.components[aq]ap=ap+1 end end;return ak.get(ao)end;function ak:has(am)return table.find(self.components,am)~=nil end;local ar=ak.get({})local as={}local at={}local au={}local av={}local function aw(ax)return ax end;local ay={register=function(az,aA,aB)if az==nil then error('Component name is required for registration')end;if aA~=nil and type(aA)~='function'then error('The component constructor must be a function, or nil')end;if aA==nil then aA=aw end;if aB==nil then aB=false end;if av[az]~=nil then error('Another component already registered with that name')end;local aC=table.getn(as)+1;av[az]=aC;table.insert(as,az)table.insert(au,aB)table.insert(at,aA)return aC end}local aD=ay.register('_ECS_ENTITY_ID_')local aE={}aE.__index=aE;local aF=100;function aE.new(aG,aH)local aI={}aI[aD]=table.create(aF)for s,aJ in pairs(aH.components)do if au[aJ]then aI[aJ]=nil else aI[aJ]=table.create(aF)end end;return setmetatable({version=0,count=0,world=aG,archetype=aH,buffers=aI},aE)end;function aE:clear(aK)local aI=self.buffers;for aL in pairs(aI)do aI[aL][aK]=nil end end;function aE:getValue(aK,am)local aI=self.buffers;if aI[am]==nil then return nil end;return aI[am][aK]end;function aE:setValue(aK,am,ax)local aI=self.buffers;if aI[am]==nil then return end;aI[am][aK]=ax end;function aE:get(aK)local ah={}local aI=self.buffers;for am in pairs(aI)do ah[am]=aI[am][aK]end;return ah end;function aE:set(aK,ah)local aI=self.buffers;for am,ax in pairs(ah)do if aI[am]~=nil then aI[am][aK]=ax end end end;function aE:setEntityId(aK,aM)self.buffers[aD][aK]=aM end;local aN={}aN.__index=aN;function aN.new(aG)return setmetatable({world=aG,version=0,COUNT=0,ENTITIES={},ARCHETYPES={}},aN)end;function aN:set(aO,aH)local aP=aH.id;local aM=self.ENTITIES[aO]local aQ=nil;if aM~=nil then if aM.archetype==aP then return end;aQ=self.ARCHETYPES[aM.archetype].chunks[aM.chunk]:get(aM.chunkIndex)self:remove(aO)end;if self.ARCHETYPES[aP]==nil then self.ARCHETYPES[aP]={count=0,lastChunk=1,nextChunkIndex=1,chunks={aE.new(self.world,aH)}}self.version=self.version+1 end;local aR=self.ARCHETYPES[aP]self.ENTITIES[aO]={archetype=aP,chunk=aR.lastChunk,chunkIndex=aR.nextChunkIndex}self.COUNT=self.COUNT+1;local aS=aR.chunks[aR.lastChunk]aS:clear(aR.nextChunkIndex)if aQ~=nil then aS:set(aR.nextChunkIndex,aQ)end;aS:setEntityId(aR.nextChunkIndex,aO)aR.count=aR.count+1;aS.count=aR.nextChunkIndex;aR.nextChunkIndex=aR.nextChunkIndex+1;aS.version=self.world.version;if aR.nextChunkIndex>aF then aR.lastChunk=aR.lastChunk+1;aR.nextChunkIndex=1;aR.chunks[aR.lastChunk]=aE.new(self.world,aH)self.version=self.version+1 end end;function aN:remove(aO)local aM=self.ENTITIES[aO]if aM==nil then return end;local aR=self.ARCHETYPES[aM.archetype]local aS=aR.chunks[aM.chunk]aS:clear(aM.chunkIndex)aS.count=aS.count-1;self.ENTITIES[aO]=nil;self.COUNT=self.COUNT-1;aR.count=aR.count-1;if aR.nextChunkIndex==1 then aR.chunks[aR.lastChunk]=nil;aR.lastChunk=aR.lastChunk-1;aR.nextChunkIndex=aF+1;self.version=self.version+1 end;if aR.count>0 then if aR.nextChunkIndex>1 then if not(aR.lastChunk==aM.chunk and aR.nextChunkIndex-1==aM.chunkIndex)then local aT=aR.chunks[aR.lastChunk]:get(aR.nextChunkIndex-1)aR.chunks[aM.chunk]:set(aM.chunkIndex,aT)local aU=aT[aD]local aV=self.ENTITIES[aU]aV.chunk=aM.chunk;aV.chunkIndex=aM.chunkIndex end;aR.nextChunkIndex=aR.nextChunkIndex-1;aR.chunks[aR.lastChunk]:clear(aR.nextChunkIndex)end else aR.nextChunkIndex=aR.nextChunkIndex-1 end end;function aN:count()return self.COUNT end;function aN:clear(aO)local aM=self.ENTITIES[aO]if aM==nil then return end;local aS=self.ARCHETYPES[aM.archetype].chunks[aM.chunk]aS:clear(aM.chunkIndex)end;function aN:getValue(aO,am)local aM=self.ENTITIES[aO]if aM==nil then return nil end;return self.ARCHETYPES[aM.archetype].chunks[aM.chunk]:getValue(aM.chunkIndex,am)end;function aN:setValue(aO,am,ax)local aM=self.ENTITIES[aO]if aM==nil then return end;local aS=self.ARCHETYPES[aM.archetype].chunks[aM.chunk]aS:setValue(aM.chunkIndex,am,ax)end;function aN:getData(aO)local aM=self.ENTITIES[aO]if aM==nil then return nil end;local aS=self.ARCHETYPES[aM.archetype].chunks[aM.chunk]return aS:get(aM.chunkIndex)end;function aN:setData(aO,am,ah)local aM=self.ENTITIES[aO]if aM==nil then return end;local aS=self.ARCHETYPES[aM.archetype].chunks[aM.chunk]aS:set(aM.chunkIndex,am,ah)end;function aN:getEntityChunk(aO)local aM=self.ENTITIES[aO]if aM==nil then return end;return self.ARCHETYPES[aM.archetype].chunks[aM.chunk],aM.chunkIndex end;function aN:filterChunks(aW)local aX={}for aP,aR in pairs(self.ARCHETYPES)do if aW(ai[aP].components)then for aq,aS in pairs(aR.chunks)do table.insert(aX,aS)end end end;return aX end;local aY={}local aZ={}local a_={}function a_.register(y)if y==nil then error('System configuration is required for its creation')end;if y.name==nil then error('The system "name" is required for registration')end;if aZ[y.name]~=nil then error('Another System already registered with that name')end;local b0=x(y)if y.step==nil then y.step='transform'end;if y.step~='task'and y.step~='render'and y.step~='process'and y.step~='processIn'and y.step~='processOut'and y.step~='transform'then error('The "step" parameter must be "task", "render", "process", "transform", "processIn" or "processOut"')end;if y.step=='task'then if y.order~=nil then error('Task-type systems do not accept the "order" parameter')end;if y.update~=nil then error('Task-type systems do not accept the "update" parameter')end;if y.beforeUpdate~=nil then error('Task-type systems do not accept the "beforeUpdate" parameter')end;if y.onEnter~=nil then error('Task-type systems do not accept the "onEnter" parameter')end;if y.execute==nil then error('The task "execute" method is required for registration')end end;if y.order==nil or y.order<0 then y.order=50 end;table.insert(aY,{name=y.name,filter=b0,requireAll=y.requireAll,requireAny=y.requireAny,requireAllOriginal=y.requireAllOriginal,requireAnyOriginal=y.requireAnyOriginal,rejectAll=y.rejectAll,rejectAny=y.rejectAny,beforeUpdate=y.beforeUpdate,update=y.update,onEnter=y.onEnter,beforeExecute=y.beforeExecute,execute=y.execute,step=y.step,order=y.order})local aC=table.getn(aY)aZ[y.name]=aC;return aC end;local b1={}b1.__index=b1;local b2=0.008;local b3=0.002;function b1.new(aG,b4)return setmetatable({world=aG,entityManager=b4,min_vruntime=0,rbtree=af(),lastEntityManagerVersion=-1,systems={}},b1)end;function b1:addSystem(b5,y)if self.systems[b5]~=nil then return end;if y==nil then y={}end;local b6={id=b5,name=aY[b5].name,requireAll=aY[b5].requireAll,requireAny=aY[b5].requireAny,requireAllOriginal=aY[b5].requireAllOriginal,requireAnyOriginal=aY[b5].requireAnyOriginal,rejectAll=aY[b5].rejectAll,rejectAny=aY[b5].rejectAny,filter=aY[b5].filter,beforeExecute=aY[b5].beforeExecute,execute=aY[b5].execute,config=y}self.systems[b5]=b6;self.lastEntityManagerVersion=0 end;function b1:run(b7)if self.entityManager.version~=self.lastEntityManagerVersion then self:update()self.lastEntityManagerVersion=self.entityManager.version end;local Q=self.rbtree;local aG=self.world;local b8=math.max(b2,0.01667-(os.clock()-b7.frameReal)-b3)local b9={}local ba=os.clock()local bb,aS,b6,bc,bd;local be=a8(Q)while be~=nil do a1(Q,be)aS=be.data[1]b6=be.data[2]bc=be.data[3]bd=be.data[4]bb=os.clock()if bd==0 then bd=bb end;local bf=b6.requireAllOriginal;if bf==nil then bf=b6.requireAnyOriginal end;local bg=table.getn(bf)local bh=b6.execute;aG.version=aG.version+1;if b6.beforeExecute~=nil then b6.beforeExecute(b7,aG,b6)end;local bi=aS.version==0 or aS.version>bc;local aI=aS.buffers;local bj=aI[aD]local bk=table.create(bg)local bl=false;for bm,bn in ipairs(bf)do if aI[bn]~=nil then bk[bm]=aI[bn]else bk[bm]={}end end;local bo={process=b7.process,frame=b7.frame,frameReal=b7.frameReal,delta=b7.delta,deltaExec=bb-bd}for aK=1,aS.count do if bh(bo,aG,bi,bj[aK],aK,table.unpack(bk))then bl=true end end;if bl then aS.version=aG.version end;be.data[3]=aG.version;be.data[4]=bb;be.key=be.key+os.clock()-bb;_(Q,be)if os.clock()-ba>b8 then break end;be=Y(be)end;local bp=a8(Q)if bp~=nil then self.min_vruntime=math.max(bp.key-h,0)else self.min_vruntime=0 end end;function b1:update()local Q=self.rbtree;local bq=self.systems;local b4=self.entityManager;local br=self.min_vruntime;local bs=self.world.version;local bt={}local bu={}local aS,b6;ac(Q,function(be)aS=be.data[1]b6=be.data[2]if bt[aS]==nil then bt[aS]={}end;if bt[aS][b6]==nil then bt[aS][b6]={}end;table.insert(bt[aS][b6],be)bu[aS]=true end)for aq,bv in pairs(bq)do local aX=b4:filterChunks(bv.filter.match)for bw,bx in pairs(aX)do bu[bx]=nil;if bt[bx]==nil then _(Q,ag(br,{bx,bv,bs,0}))elseif bt[bx][bv]==nil then _(Q,ag(br,{bx,bv,bs,0}))end end end;for by,s in pairs(bu)do for bz,b9 in pairs(bt[by])do for s,be in ipairs(b9)do a1(Q,be)end end end end;local function bA(aG,bq)local bB={processIn={},process={},processOut={},transform={},render={}}local bC={}for aL,b6 in pairs(bq)do if b6.update~=nil then if bB[b6.step][b6.order]==nil then bB[b6.step][b6.order]={}end;table.insert(bB[b6.step][b6.order],b6)end;if b6.onEnter~=nil then table.insert(bC,b6)end end;local bD=function(bE,b4,b7,bF)for aq,bG in pairs(bB[bE])do for bw,b6 in pairs(bG)do b6.lastUpdate=b7;local bf=b6.requireAllOriginal;if bf==nil then bf=b6.requireAnyOriginal end;local bg=table.getn(bf)local bH=b6.version;local aX=b4:filterChunks(b6.filter.match)local bI=b6.update;aG.version=aG.version+1;if b6.beforeUpdate~=nil then b6.beforeUpdate(b7,bF,aG,b6)end;for aL,aS in pairs(aX)do local bi=aS.version==0 or aS.version>bH;local aI=aS.buffers;local bj=aI[aD]local bk=table.create(bg)local bl=false;for bm,bn in ipairs(bf)do if aI[bn]~=nil then bk[bm]=aI[bn]else bk[bm]={}end end;for aK=1,aS.count do if bI(b7,aG,bi,bj[aK],aK,table.unpack(bk))then bl=true end end;if bl then aS.version=aG.version end end;b6.version=aG.version end end end;local bJ=function(bK,b4,b7)aG.version=aG.version+1;for aO,bL in pairs(bK)do local bM=x({requireAny=bL})local aS,aK=b4:getEntityChunk(aO)if aS~=nil then local aI=aS.buffers;for bw,b6 in pairs(bC)do if b6.filter.match(aS.archetype.components)then local bf=b6.requireAllOriginal;if bf==nil then bf=b6.requireAnyOriginal end;if bM.match(bf)then local bk=table.create(table.getn(bf))for bm,bn in ipairs(bf)do if aI[bn]~=nil then bk[bm]=aI[bn]else bk[bm]={}end end;if b6.onEnter(b7,aG,aO,aK,table.unpack(bk))then aS.version=aG.version end end end end end end end;return bD,bJ end;local bN={Component=ay,System=a_,Filter=x}function bN.newWorld(bq,y)if y==nil then y={}end;if y.frequency==nil then y.frequency=30 end;local bO=math.round(math.abs(y.frequency)/2)*2;if bO<2 then bO=2 end;if y.frequency~=bO then y.frequency=bO;print(string.format(">>> ATTENTION! The execution frequency of world has been changed to %d <<<",bO))end;local bP=1;local bQ={}local bR;local bS,bT;local bU=1000/y.frequency/1000;local bF=1;local bV=nil;local bW=0;local bX=0;local bY=0;local bZ=0;local b_=0;local c0=0;local c1=10;local c2=0;local b4;local c3;local c4;local c5={}local c6={}local c7={}local c8={}local aG;local c9;local ca=false;aG={version=0,frequency=y.frequency,create=function()local aC=bP;bP=bP+1;c3:set(aC,ar)c5[aC]=true;c8[aC]=ar;ca=true;return aC end,get=function(aM,am)if c5[aM]==true then return c3:getValue(aM,am)elseif c7[aM]~=nil then return c4:getValue(aM,am)else return b4:getValue(aM,am)end end,set=function(aM,am,...)local aH=c8[aM]if aH==nil then return end;ca=true;local cb=aH:with(am)local cc=aH~=cb;if cc then c8[aM]=cb end;local ax=at[am](table.unpack({...}))if c5[aM]==true then if cc then c3:set(aM,cb)end;c3:setValue(aM,am,ax)else if cc then if c7[aM]==nil then c7[aM]={received={},lost={}}c4:set(aM,cb)c4:setData(aM,b4:getData(aM))else c4:set(aM,cb)end end;if c7[aM]~=nil then c4:setValue(aM,am,ax)local cd=false;for aL,t in pairs(c7[aM].lost)do if t==am then table.remove(c7[aM].lost,aL)cd=true;break end end;if not cd then table.insert(c7[aM].received,am)end end;b4:setValue(aM,am,ax)end end,remove=function(aM,am)local aH=c8[aM]if aH==nil then return end;if c6[aM]==true then return end;ca=true;if am==nil then if c5[aM]==true then c3:remove(aM)c5[aM]=nil;c8[aM]=nil else if c6[aM]==nil then c6[aM]=true end end else local cb=aH:without(am)local cc=aH~=cb;if cc then c8[aM]=cb end;if c5[aM]==true then if cc then c3:set(aM,cb)end else if cc then if c7[aM]==nil then c7[aM]={received={},lost={}}c4:set(aM,cb)c4:setData(aM,b4:getData(aM))else c4:set(aM,cb)end end;if c7[aM]~=nil then c4:setValue(aM,am,nil)local cd=false;for aL,t in pairs(c7[aM].received)do if t==am then table.remove(c7[aM].received,aL)cd=true;break end end;if not cd then table.insert(c7[aM].lost,am)end end;b4:setValue(aM,am,nil)end end end,has=function(aM,am)if c8[aM]==nil then return false end;return c8[aM]:has(am)end,forEach=function(b0,ad)local ce=false;local cf=function()ce=true end;local aX=b4:filterChunks(b0.match)for aL,aS in pairs(aX)do local aI=aS.buffers;local bk=table.create(table.getn(b0.components))for bm,bn in ipairs(b0.components)do if aI[bn]~=nil then bk[bm]=aI[bn]else bk[bm]={}end end;local bj=aI[aD]local bl=false;for aK=1,aS.count do if ad(cf,bj[aK],aK,table.unpack(bk))then bl=true end;if ce then break end end;if bl then aS.version=aG.version end;if ce then break end end end,addSystem=function(b5,cg,y)if b5==nil then return end;if aY[b5]==nil then error('There is no registered system with the given ID')end;if aY[b5].step=='task'then bR:addSystem(b5)else if bQ[b5]~=nil then return end;if b4:count()>0 or c3:count()>0 then error('Adding systems is not allowed after adding entities in the world')end;if y==nil then y={}end;local b6={id=b5,name=aY[b5].name,requireAll=aY[b5].requireAll,requireAny=aY[b5].requireAny,requireAllOriginal=aY[b5].requireAllOriginal,requireAnyOriginal=aY[b5].requireAnyOriginal,rejectAll=aY[b5].rejectAll,rejectAny=aY[b5].rejectAny,filter=aY[b5].filter,beforeUpdate=aY[b5].beforeUpdate,update=aY[b5].update,onEnter=aY[b5].onEnter,step=aY[b5].step,order=aY[b5].order,version=0,lastUpdate=bZ,config=y}if cg~=nil and cg<0 then b6.order=50 end;bQ[b5]=b6;c2=0 end end,alive=function(aM)if c8[aM]==nil then return false end;if c5[aM]==true then return false end;if c6[aM]==true then return false end;return true end,destroy=function()if aG._steppedConn~=nil then aG._steppedConn:Disconnect()aG._steppedConn=nil end;if aG._heartbeatConn~=nil then aG._heartbeatConn:Disconnect()aG._heartbeatConn=nil end;if aG._renderSteppedConn~=nil then aG._renderSteppedConn:Disconnect()aG._renderSteppedConn=nil end;b4=nil;c3=nil;c4=nil;c7=nil;c6=nil;bQ=nil;bS=nil;bT=nil;c9=nil;c8=nil;bR=nil;aG.create=nil;aG.set=nil;aG.get=nil;aG.remove=nil;aG.has=nil;aG.forEach=nil;aG.addSystem=nil;aG.alive=nil;aG.update=nil;aG.destroy=nil;aG=nil end,update=function(bE,ch)if not a:IsRunning()then return end;if bV==nil then bV=ch end;local ci=ch;ch=ch-bV;if c2<aj then bS,bT=bA(aG,bQ)c2=aj end;if bE~='process'then if bZ~=b_ then bF=1+(ch-bZ)/bU else bF=1 end;if bE=='processIn'then bX=ch;bY=ci;if bW==0 then bW=bX end;if bZ==0 then bZ=bX;b_=bX end;c0=bX-bW;bF=1 elseif bE=='render'then bW=bX end;local b7={process=bZ,frame=bX,frameReal=bY,now=ch,nowReal=ci,delta=c0}bS(bE,b4,b7,bF)while ca do c9()end;if bE=='transform'then bR:run(b7)end else local cj=bZ;local ck=0;local cl=false;while bZ<bX and ck<c1 do cl=true;if c2<aj then bS,bT=bA(aG,bQ)c2=aj end;bS(bE,b4,{process=bZ,frame=bX,frameReal=bY,now=ch,nowReal=ci,delta=c0},1)while ca do c9()end;ck=ck+1;bZ=bZ+bU end;if cl then b_=cj end end end}c9=function()if not ca then return end;ca=false;for aO,cm in pairs(c6)do b4:remove(aO)c8[aO]=nil;if c7[aO]~=nil then c7[aO]=nil;c4:remove(aO)end end;local cn=false;local bK={}for aO,cl in pairs(c7)do b4:set(aO,c8[aO])b4:setData(aO,c4:getData(aO))c4:remove(aO)if table.getn(cl.received)>0 then bK[aO]=cl.received;cn=true end end;c7={}for aO,cm in pairs(c5)do b4:set(aO,c8[aO])b4:setData(aO,c3:getData(aO))c3:remove(aO)bK[aO]=c8[aO].components;cn=true end;c5={}if cn then bT(bK,b4)bK=nil end end;b4=aN.new(aG)c3=aN.new(aG)c4=aN.new(aG)bR=b1.new(aG,b4)if bq~=nil then for aq,b6 in pairs(bq)do aG.addSystem(b6)end end;if not y.disableDefaultSystems then aG.addSystem(bN.Util.BasePartToEntityProcessInSystem)aG.addSystem(bN.Util.MoveForwardSystem)aG.addSystem(bN.Util.EntityToBasePartProcessOutSystem)aG.addSystem(bN.Util.BasePartToEntityTransformSystem)aG.addSystem(bN.Util.EntityToBasePartTransformSystem)aG.addSystem(bN.Util.EntityToBasePartInterpolationTransformSystem)aG.addSystem(bN.Util.EntityToBasePartInterpolationCustomTransformSystem)end;if not y.disableAutoUpdate then aG._steppedConn=a.Stepped:Connect(function()aG.update('processIn',os.clock())aG.update('process',os.clock())aG.update('processOut',os.clock())end)aG._heartbeatConn=a.Heartbeat:Connect(function()aG.update('transform',os.clock())end)aG._renderSteppedConn=a.RenderStepped:Connect(function()aG.update('render',os.clock())end)end;return aG end;bN.Util={}function bN.Util.NewBasePartEntity(aG,co,cp,cq,cr)local aO=aG.create()aG.set(aO,bN.Util.BasePartComponent,co)aG.set(aO,bN.Util.PositionComponent,co.CFrame.Position)aG.set(aO,bN.Util.RotationComponent,co.CFrame.RightVector,co.CFrame.UpVector,co.CFrame.LookVector)if cp then aG.set(aO,bN.Util.BasePartToEntitySyncComponent)end;if cq then aG.set(aO,bN.Util.EntityToBasePartSyncComponent)end;if cr then aG.set(aO,bN.Util.PositionInterpolationComponent,co.CFrame.Position)aG.set(aO,bN.Util.RotationInterpolationComponent,co.CFrame.RightVector,co.CFrame.UpVector,co.CFrame.LookVector)end;return aO end;bN.Util.BasePartComponent=ay.register('BasePart',function(cs)if cs==nil or cs['IsA']==nil or cs:IsA('BasePart')==false then error("This component only works with BasePart objects")end;return cs end)bN.Util.BasePartToEntitySyncComponent=ay.register('BasePartToEntitySync',nil,true)bN.Util.EntityToBasePartSyncComponent=ay.register('EntityToBasePartSync',nil,true)bN.Util.PositionComponent=ay.register('Position',function(ct)if ct~=nil and typeof(ct)~='Vector3'then error("This component only works with Vector3 objects")end;if ct==nil then ct=Vector3.new(0,0,0)end;return ct end)bN.Util.PositionInterpolationComponent=ay.register('PositionInterpolation',function(ct)if ct~=nil and typeof(ct)~='Vector3'then error("This component only works with Vector3 objects")end;if ct==nil then ct=Vector3.new(0,0,0)end;return{ct,ct}end)bN.Util.InterpolationCustomComponent=ay.register('InterpolationCustom',function(cu,cv,cw,cx,cy,cz)if cu==nil then return nil end;return{cu,cv,cw,cx,cy,cz}end)local cA=Vector3.new(1,0,0)local cB=Vector3.new(0,1,0)local cC=Vector3.new(0,0,1)bN.Util.RotationComponent=ay.register('Rotation',function(cD,cE,cF)if cD~=nil and typeof(cD)~='Vector3'then error("This component only works with Vector3 objects [param=rightVector]")end;if cE~=nil and typeof(cE)~='Vector3'then error("This component only works with Vector3 objects [param=upVector]")end;if cF~=nil and typeof(cF)~='Vector3'then error("This component only works with Vector3 objects [param=lookVector]")end;if cD==nil then cD=cA end;if cE==nil then cE=cB end;if cF==nil then cF=cC end;return{cD,cE,cF}end)bN.Util.RotationInterpolationComponent=ay.register('RotationInterpolation',function(cD,cE,cF)if cD~=nil and typeof(cD)~='Vector3'then error("This component only works with Vector3 objects [param=rightVector]")end;if cE~=nil and typeof(cE)~='Vector3'then error("This component only works with Vector3 objects [param=upVector]")end;if cF~=nil and typeof(cF)~='Vector3'then error("This component only works with Vector3 objects [param=lookVector]")end;if cD==nil then cD=cA end;if cE==nil then cE=cB end;if cF==nil then cF=cC end;return{{cD,cE,cF},{cD,cE,cF}}end)bN.Util.MoveForwardComponent=ay.register('MoveForward',nil,true)bN.Util.MoveSpeedComponent=ay.register('MoveSpeed',function(cG)if cG==nil or typeof(cG)~='number'then error("This component only works with number value")end;return cG end)local function cH(b7,aG,bi,aM,aK,cI,cJ,cK)local cL=false;local co=cI[aK]if co~=nil then local ct=cJ[aK]local cM=co.CFrame.Position;if ct==nil or not l(cM,ct)then cJ[aK]=cM;cL=true end;local cN=cK[aK]local cD=co.CFrame.RightVector;local cE=co.CFrame.UpVector;local cF=co.CFrame.LookVector;if cN==nil or not l(cD,cN[1])or not l(cE,cN[2])or not l(cF,cN[3])then cK[aK]={cD,cE,cF}cL=true end end;return cL end;bN.Util.BasePartToEntityProcessInSystem=a_.register({name='BasePartToEntityProcessIn',step='processIn',order=10,requireAll={bN.Util.BasePartComponent,bN.Util.PositionComponent,bN.Util.RotationComponent,bN.Util.BasePartToEntitySyncComponent},rejectAny={bN.Util.PositionInterpolationComponent,bN.Util.RotationInterpolationComponent},update=cH})bN.Util.BasePartToEntityTransformSystem=a_.register({name='BasePartToEntityTransform',step='transform',order=10,requireAll={bN.Util.BasePartComponent,bN.Util.PositionComponent,bN.Util.RotationComponent,bN.Util.BasePartToEntitySyncComponent},rejectAny={bN.Util.PositionInterpolationComponent,bN.Util.RotationInterpolationComponent},update=cH})local function cO(b7,aG,bi,aM,aK,cI,cJ,cK)if not bi then return false end;local cL=false;local co=cI[aK]local ct=cJ[aK]local cN=cK[aK]if co~=nil then local cM=co.CFrame.Position;local cD=co.CFrame.RightVector;local cE=co.CFrame.UpVector;local cF=co.CFrame.LookVector;local cP=co.CFrame;if ct~=nil and not l(cM,ct)then cP=CFrame.fromMatrix(ct,cD,cE,cF*-1)cL=true end;if cN~=nil then if not l(cD,cN[1])or not l(cE,cN[2])or not l(cF,cN[3])then cP=CFrame.fromMatrix(cP.Position,cN[1],cN[2],cN[3]*-1)cL=true end end;if cL then co.CFrame=cP end end;return cL end;bN.Util.EntityToBasePartProcessOutSystem=a_.register({name='EntityToBasePartProcess',step='processOut',order=100,requireAll={bN.Util.BasePartComponent,bN.Util.PositionComponent,bN.Util.RotationComponent,bN.Util.EntityToBasePartSyncComponent},update=cO})bN.Util.EntityToBasePartTransformSystem=a_.register({name='EntityToBasePartTransform',step='transform',order=100,requireAll={bN.Util.BasePartComponent,bN.Util.PositionComponent,bN.Util.RotationComponent,bN.Util.EntityToBasePartSyncComponent},rejectAny={bN.Util.PositionInterpolationComponent,bN.Util.RotationInterpolationComponent},update=cO})local cQ=1;bN.Util.EntityToBasePartInterpolationTransformSystem=a_.register({name='EntityToBasePartInterpolationTransform',step='transform',order=100,requireAll={bN.Util.BasePartComponent,bN.Util.PositionComponent,bN.Util.RotationComponent,bN.Util.PositionInterpolationComponent,bN.Util.RotationInterpolationComponent,bN.Util.EntityToBasePartSyncComponent},rejectAny={bN.Util.InterpolationCustomComponent},beforeUpdate=function(b7,bF,aG,b6)cQ=bF end,update=function(b7,aG,bi,aM,aK,cI,cJ,cK,cR,cS)local co=cI[aK]local ct=cJ[aK]local cN=cK[aK]if co~=nil then local cP=co.CFrame;if ct~=nil then local cD=co.CFrame.RightVector;local cE=co.CFrame.UpVector;local cF=co.CFrame.LookVector;if not l(cR[aK][1],ct)then cR[aK][2]=cR[aK][1]cR[aK][1]=ct end;local cT=cR[aK][2]cP=CFrame.fromMatrix(cT:Lerp(ct,cQ),cD,cE,cF*-1)end;if cN~=nil then if not l(cS[aK][1][1],cN[1])or not l(cS[aK][1][2],cN[2])or not l(cS[aK][1][3],cN[3])then cS[aK][2]=cS[aK][1]cS[aK][1]=cN end;local cU=cS[aK][2]cP=CFrame.fromMatrix(cP.Position,cU[1]:Lerp(cN[1],cQ),cU[2]:Lerp(cN[2],cQ),(cU[3]*-1):Lerp(cN[3]*-1,cQ))end;co.CFrame=cP end;return false end})bN.Util.EntityToBasePartInterpolationCustomTransformSystem=a_.register({name='EntityToBasePartInterpolationCustomTransform',step='transform',order=100,requireAll={bN.Util.BasePartComponent,bN.Util.PositionComponent,bN.Util.RotationComponent,bN.Util.InterpolationCustomComponent,bN.Util.EntityToBasePartSyncComponent},update=function(b7,aG,bi,aM,aK,cI,cJ,cK,cV)local co=cI[aK]local ct=cJ[aK]local cN=cK[aK]local cW=cV[aK]if co~=nil and ct~=nil and cN~=nil and cW~=nil then local cu=cW[1]local cv=cW[2]local cX=(b7.frame-cv)/cu;local cP=CFrame.fromMatrix(cW[3],cW[4],cW[5],cW[6]*-1)co.CFrame=cP:Lerp(CFrame.fromMatrix(ct,cN[1],cN[2],cN[3]*-1),cX)end;return false end})local cY=1;bN.Util.MoveForwardSystem=a_.register({name='MoveForward',step='process',requireAll={bN.Util.MoveSpeedComponent,bN.Util.PositionComponent,bN.Util.RotationComponent,bN.Util.MoveForwardComponent},beforeUpdate=function(b7,bF,aG,b6)cY=aG.frequency/60 end,update=function(b7,aG,bi,aM,aK,cZ,cJ,cK,c_)local ct=cJ[aK]if ct~=nil then local cN=cK[aK]if cN~=nil then local cG=cZ[aK]if cG~=nil then cJ[aK]=ct+cG/cY*cN[3]return true end end end;return false end})return bN