--[[
	Roblox-ECS v1.2 [2020-12-05 20:03]

	Roblox-ECS is a tiny and easy to use ECS (Entity Component System) engine for
	game development on the Roblox platform

	This is a minified version of Roblox-ECS, to see the full source code visit
	https://github.com/nidorx/roblox-ecs

	Discussions about this script are at https://devforum.roblox.com/t/841175

	------------------------------------------------------------------------------

	MIT License

	Copyright (c) 2020 Alex Rodin

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.
]]
local a=game:GetService('RunService')local b=0.000000001;local function c(d)if d==nil then d={}end;local e={}local f={}for g,h in pairs(d)do if h~=nil and e[h]==nil then table.insert(f,h)e[h]=true end end;table.sort(f)return f end;local function i(j)j=c(j)return'_'..table.concat(j,'_'),j end;local k={}local function l(m)local n={}if m==nil then m={}end;if m.RequireAll==nil and m.RequireAny==nil then error('It is necessary to define the components using the "RequireAll" or "RequireAny" parameters')end;if m.RequireAll~=nil and m.RequireAny~=nil then error('It is not allowed to use the "RequireAll" and "RequireAny" settings simultaneously')end;if m.RequireAll~=nil then m.RequireAllOriginal=m.RequireAll;m.RequireAll=c(m.RequireAll)if table.getn(m.RequireAll)==0 then error('You must enter at least one component id in the "RequireAll" field')end elseif m.RequireAny~=nil then m.RequireAnyOriginal=m.RequireAny;m.RequireAny=c(m.RequireAny)if table.getn(m.RequireAny)==0 then error('You must enter at least one component id in the "RequireAny" field')end end;if m.RejectAll~=nil and m.RejectAny~=nil then error('It is not allowed to use the "RejectAll" and "RejectAny" settings simultaneously')end;if m.RejectAll~=nil then m.RejectAll=c(m.RejectAll)if table.getn(m.RejectAll)==0 then error('You must enter at least one component id in the "RejectAll" field')end elseif m.RejectAny~=nil then m.RejectAny=c(m.RejectAny)if table.getn(m.RejectAny)==0 then error('You must enter at least one component id in the "RejectAny" field')end end;local o,p=i(m.RequireAll)local q,r=i(m.RequireAny)local s,t=i(m.RejectAll)local u,v=i(m.RejectAny)local w=m.RequireAllOriginal;if w==nil then w=m.RequireAnyOriginal end;return{Components=w,Match=function(w)local x=n[w]if x==false then return false elseif x==true then return true else local y=k[w]if y==nil then y={MatchAny={},MatchAll={},RejectAny={},RejectAll={}}k[w]=y end;if u~='_'then if y.RejectAny[u]or y.RejectAll[u]then n[w]=false;return false end;for g,h in pairs(v)do if table.find(w,h)then n[w]=false;y.MatchAny[u]=true;y.RejectAny[u]=true;return false end end end;if s~='_'then if y.RejectAll[s]then n[w]=false;return false end;local z=true;for g,h in pairs(t)do if not table.find(w,h)then z=false;break end end;if z then n[w]=false;y.MatchAll[s]=true;y.RejectAll[s]=true;return false end end;if q~='_'then if y.MatchAny[q]or y.MatchAll[q]then n[w]=true;return true end;for g,h in pairs(r)do if table.find(w,h)then y.MatchAny[q]=true;n[w]=true;return true end end end;if o~='_'then if y.MatchAll[o]then n[w]=true;return true end;local z=true;for g,h in pairs(p)do if not table.find(w,h)then z=false;break end end;if z then n[w]=true;y.MatchAll[o]=true;y.RejectAll[o]=true;return true end end;n[w]=false;return false end end}end;local A=0;local B=1;local C={key=0,color=A}local function D(E,F)local G=F.right;F.right=G.left;if G.left~=C then G.left.parent=F end;G.parent=F.parent;if F.parent==C then E.root=G elseif F==F.parent.left then F.parent.left=G else F.parent.right=G end;G.left=F;F.parent=G end;local function H(E,F)local I=F.left;F.left=I.right;if I.right~=C then I.right.parent=F end;I.parent=F.parent;if F.parent==C then E.root=I elseif F==F.parent.right then F.parent.right=I else F.parent.left=I end;I.right=F;F.parent=I end;local function J(E,F,K)if F.parent==C then E.root=K elseif F==F.parent.left then F.parent.left=K else F.parent.right=K end;K.parent=F.parent end;local function L(F)while F.left~=C do F=F.left end;return F end;local function M(F)if F==C then return nil end;if F.parent==F then return nil end;if F.right~=C then return L(F.right)end;local N;while true do N=F.parent;if N==C then return nil end;if F==N.right then F=N else break end end;return N end;local function O(E,F)local N=C;local P=E.root;while P~=C do N=P;if F.key<P.key then P=P.left else P=P.right end end;F.parent=N;if N==C then E.root=F elseif F.key<N.key then N.left=F else N.right=F end;F.left=C;F.right=C;F.color=B;while F.parent.color==B do if F.parent==F.parent.parent.left then N=F.parent.parent.right;if N.color==B then F.parent.color=A;N.color=A;F.parent.parent.color=B;F=F.parent.parent else if F==F.parent.right then F=F.parent;D(E,F)end;F.parent.color=A;F.parent.parent.color=B;H(E,F.parent.parent)end else N=F.parent.parent.left;if N.color==B then F.parent.color=A;N.color=A;F.parent.parent.color=B;F=F.parent.parent else if F==F.parent.left then F=F.parent;H(E,F)end;F.parent.color=A;F.parent.parent.color=B;D(E,F.parent.parent)end end end;E.root.color=A end;local function Q(E,F)if F==C then return end;local R,S;local T=F.color;if F.left==C then R=F.right;J(E,F,F.right)elseif F.right==C then R=F.left;J(E,F,F.left)else local U=L(F.right)T=U.color;R=U.right;if U.parent==F then R.parent=U else J(E,U,U.right)U.right=F.right;U.right.parent=U end;J(E,F,U)U.left=F.left;U.left.parent=U;U.color=F.color end;if T~=A then return end;while R~=E.root and R.color==A do if R==R.parent.left then S=R.parent.right;if S.color==B then S.color=A;R.parent.color=B;D(E,R.parent)S=R.parent.right end;if S.left.color==A and S.right.color==A then S.color=B;R=R.parent else if S.right.color==A then S.left.color=A;S.color=B;H(E,S)S=R.parent.right end;S.color=R.parent.color;R.parent.color=A;S.right.color=A;D(E,R.parent)R=E.root end else S=R.parent.left;if S.color==B then S.color=A;R.parent.color=B;H(E,R.parent)S=R.parent.left end;if S.right.color==A and S.left.color==A then S.color=B;R=R.parent else if S.left.color==A then S.right.color=A;S.color=B;D(E,S)S=R.parent.left end;S.color=R.parent.color;R.parent.color=A;S.left.color=A;H(E,R.parent)R=E.root end end end;R.color=A end;local function V(E,W)local F=E.root;while F~=C and W~=F.key do if W<F.key then F=F.left else F=F.right end end;return F end;local function X(E)if E.root==C then return nil end;return L(E.root)end;local function Y(E,Z)local _={}local F=X(E)while F~=nil do if Z(F)then table.insert(_,F)end;F=M(F)end;return _ end;local function a0(E,a1)local F=X(E)while F~=nil do a1(F)F=M(F)end end;local function a2(E)local _={}local F=X(E)while F~=nil do table.insert(_,F)F=M(F)end;return _ end;local function a3()return{root=C,count=0}end;local function a4(W,a5)return{key=W,data=a5}end;local a6={}local a7=os.clock()local a8={}a8.__index=a8;function a8.Get(w)local a9;a9,w=i(w)if a6[a9]==nil then a6[a9]=setmetatable({Id=a9,Components=w},a8)a7=os.clock()end;return a6[a9]end;function a8:With(aa)local ab=self.Components;if table.find(ab,aa)~=nil then return self end;local ac=table.getn(ab)local ad=table.create(ac+1)ad[0]=aa;table.move(ab,1,ac,2,ad)return a8.Get(ad)end;function a8:Without(aa)local ab=self.Components;if table.find(ab,aa)==nil then return self end;local ac=table.getn(ab)local ad=table.create(ac-1)local ae=1;for af=1,ac do if ab[af]~=aa then ad[ae]=ab[af]ae=ae+1 end end;return a8.Get(ad)end;function a8:Has(aa)return table.find(self.Components,aa)~=nil end;local ag=a8.Get({})local ah={}local ai={}local aj={}local ak={}local al={}local function am(an)return an end;local ao={}local function ap(aq,ar,as,at)if aq==nil then error('Component name is required for registration')end;if ar~=nil and type(ar)~='function'then error('The component constructor must be a function, or nil')end;if ar==nil then ar=am end;if as==nil then as=false end;if at==nil then at=ao end;if al[aq]~=nil then error('Another component already registered with that name')end;local au=table.getn(ah)+1;al[aq]=au;table.insert(ah,aq)table.insert(aj,at)table.insert(ak,as)table.insert(ai,ar)return au end;local av=ap('_ECS_ENTITY_ID_')local aw={}aw.__index=aw;local ax=10;function aw.New(ay,az)local aA={}aA[av]=table.create(ax)for g,aB in pairs(az.Components)do if ak[aB]then aA[aB]=nil else aA[aB]=table.create(ax)end end;return setmetatable({Version=0,Count=0,World=ay,Archetype=az,Buffers=aA},aw)end;function aw:Clear(aC)local aA=self.Buffers;for aD in pairs(aA)do aA[aD][aC]=nil end end;function aw:GetValue(aC,aa)local aA=self.Buffers;if aA[aa]==nil then return nil end;return aA[aa][aC]end;function aw:SetValue(aC,aa,an)local aA=self.Buffers;if aA[aa]==nil then return end;aA[aa][aC]=an end;function aw:Get(aC)local a5={}local aA=self.Buffers;for aa in pairs(aA)do a5[aa]=aA[aa][aC]end;return a5 end;function aw:Set(aC,a5)local aA=self.Buffers;for aa,an in pairs(a5)do if aA[aa]~=nil then aA[aa][aC]=an end end end;function aw:SetEntityId(aC,aE)self.Buffers[av][aC]=aE end;local aF={}aF.__index=aF;function aF.New(ay)return setmetatable({World=ay,Version=0,CountValue=0,Entities={},Archetypes={}},aF)end;function aF:Set(aG,az)local aH=az.Id;local aE=self.Entities[aG]local aI=nil;if aE~=nil then if aE.Archetype==aH then return end;aI=self.Archetypes[aE.Archetype].Chunks[aE.Chunk]:Get(aE.ChunkIndex)self:Remove(aG)end;if self.Archetypes[aH]==nil then self.Archetypes[aH]={Count=0,LastChunk=1,NextChunkIndex=1,Chunks={aw.New(self.World,az)}}self.Version=self.Version+1 end;local aJ=self.Archetypes[aH]self.Entities[aG]={Archetype=aH,Chunk=aJ.LastChunk,ChunkIndex=aJ.NextChunkIndex}self.CountValue=self.CountValue+1;local aK=aJ.Chunks[aJ.LastChunk]aK:Clear(aJ.NextChunkIndex)if aI~=nil then aK:Set(aJ.NextChunkIndex,aI)end;aK:SetEntityId(aJ.NextChunkIndex,aG)aJ.Count=aJ.Count+1;aK.Count=aJ.NextChunkIndex;aJ.NextChunkIndex=aJ.NextChunkIndex+1;aK.Version=self.World.Version;if aJ.NextChunkIndex>ax then aJ.LastChunk=aJ.LastChunk+1;aJ.NextChunkIndex=1;aJ.Chunks[aJ.LastChunk]=aw.New(self.World,az)self.Version=self.Version+1 end end;function aF:Remove(aG)local aE=self.Entities[aG]if aE==nil then return end;local aJ=self.Archetypes[aE.Archetype]local aK=aJ.Chunks[aE.Chunk]aK:Clear(aE.ChunkIndex)aK.Count=aK.Count-1;self.Entities[aG]=nil;self.CountValue=self.CountValue-1;aJ.Count=aJ.Count-1;if aJ.NextChunkIndex==1 then aJ.Chunks[aJ.LastChunk]=nil;aJ.LastChunk=aJ.LastChunk-1;aJ.NextChunkIndex=ax+1;self.Version=self.Version+1 end;if aJ.Count>0 then if aJ.NextChunkIndex>1 then if not(aJ.LastChunk==aE.Chunk and aJ.NextChunkIndex-1==aE.ChunkIndex)then local aL=aJ.Chunks[aJ.LastChunk]:Get(aJ.NextChunkIndex-1)aJ.Chunks[aE.Chunk]:Set(aE.ChunkIndex,aL)local aM=aL[av]local aN=self.Entities[aM]aN.Chunk=aE.Chunk;aN.ChunkIndex=aE.ChunkIndex end;aJ.NextChunkIndex=aJ.NextChunkIndex-1;aJ.Chunks[aJ.LastChunk]:Clear(aJ.NextChunkIndex)end else aJ.NextChunkIndex=aJ.NextChunkIndex-1 end end;function aF:Count()return self.CountValue end;function aF:Clear(aG)local aE=self.Entities[aG]if aE==nil then return end;local aK=self.Archetypes[aE.Archetype].Chunks[aE.Chunk]aK:Clear(aE.ChunkIndex)end;function aF:GetValue(aG,aa)local aE=self.Entities[aG]if aE==nil then return nil end;return self.Archetypes[aE.Archetype].Chunks[aE.Chunk]:GetValue(aE.ChunkIndex,aa)end;function aF:SetValue(aG,aa,an)local aE=self.Entities[aG]if aE==nil then return end;local aK=self.Archetypes[aE.Archetype].Chunks[aE.Chunk]aK:SetValue(aE.ChunkIndex,aa,an)end;function aF:GetData(aG)local aE=self.Entities[aG]if aE==nil then return nil end;local aK=self.Archetypes[aE.Archetype].Chunks[aE.Chunk]return aK:Get(aE.ChunkIndex)end;function aF:SetData(aG,aa,a5)local aE=self.Entities[aG]if aE==nil then return end;local aK=self.Archetypes[aE.Archetype].Chunks[aE.Chunk]aK:Set(aE.ChunkIndex,aa,a5)end;function aF:GetEntityChunk(aG)local aE=self.Entities[aG]if aE==nil then return end;return self.Archetypes[aE.Archetype].Chunks[aE.Chunk],aE.ChunkIndex end;function aF:FilterChunks(aO)local aP={}for aH,aJ in pairs(self.Archetypes)do if aO(a6[aH].Components)then for af,aK in pairs(aJ.Chunks)do table.insert(aP,aK)end end end;return aP end;local aQ={}local aR={}local aS={'task','render','process','processIn','processOut','transform'}local function aT(m)if m==nil then error('System configuration is required for its creation')end;if m.Name==nil then error('The system "Name" is required for registration')end;if aR[m.Name]~=nil then error('Another System already registered with that name')end;if m.Step==nil then m.Step='transform'end;if not table.find(aS,m.Step)then error('The "step" parameter must one of ',table.concat(aS,', '))end;if m.Step=='task'then if m.Order~=nil then error('Task-type systems do not accept the "Order" parameter')end;if m.ShouldUpdate~=nil then error('Task-type systems do not accept the "ShouldUpdate" parameter')end;if m.BeforeUpdate~=nil then error('Task-type systems do not accept the "BeforeUpdate" parameter')end;if m.Update~=nil then error('Task-type systems do not accept the "Update" parameter')end;if m.AfterUpdate~=nil then error('Task-type systems do not accept the "AfterUpdate" parameter')end;if m.OnEnter~=nil then error('Task-type systems do not accept the "OnEnter" parameter')end;if m.Execute==nil then error('The task "Execute" method is required for registration')end end;if m.Order==nil or m.Order<0 then m.Order=50 end;table.insert(aQ,{Filter=l(m),Name=m.Name,RequireAll=m.RequireAll,RequireAny=m.RequireAny,RequireAllOriginal=m.RequireAllOriginal,RequireAnyOriginal=m.RequireAnyOriginal,RejectAll=m.RejectAll,RejectAny=m.RejectAny,ShouldUpdate=m.ShouldUpdate,BeforeUpdate=m.BeforeUpdate,Update=m.Update,AfterUpdate=m.AfterUpdate,OnCreate=m.OnCreate,OnEnter=m.OnEnter,OnRemove=m.OnRemove,BeforeExecute=m.BeforeExecute,Execute=m.Execute,Step=m.Step,Order=m.Order})local au=table.getn(aQ)aR[m.Name]=au;return au end;local aU={}aU.__index=aU;local aV=0.008;local aW=0.002;function aU.New(ay,aX)return setmetatable({World=ay,EntityManager=aX,min_vruntime=0,rbtree=a3(),LastEntityManagerVersion=-1,Systems={}},aU)end;function aU:AddSystem(aY,m)if self.Systems[aY]~=nil then return end;if m==nil then m={}end;local aZ={Id=aY,name=aQ[aY].Name,RequireAll=aQ[aY].RequireAll,RequireAny=aQ[aY].RequireAny,RequireAllOriginal=aQ[aY].RequireAllOriginal,RequireAnyOriginal=aQ[aY].RequireAnyOriginal,RejectAll=aQ[aY].RejectAll,RejectAny=aQ[aY].RejectAny,Filter=aQ[aY].Filter,BeforeExecute=aQ[aY].BeforeExecute,Execute=aQ[aY].Execute,Config=m}self.Systems[aY]=aZ;self.LastEntityManagerVersion=0 end;function aU:Run(a_)if self.EntityManager.Version~=self.LastEntityManagerVersion then self:Update()self.LastEntityManagerVersion=self.EntityManager.Version end;local E=self.rbtree;local ay=self.World;local b0=math.max(aV,0.01667-(os.clock()-a_.frameReal)-aW)local b1={}local b2=os.clock()local b3,aK,aZ,b4,b5;local b6=X(E)while b6~=nil do Q(E,b6)aK=b6.data[1]aZ=b6.data[2]b4=b6.data[3]b5=b6.data[4]b3=os.clock()if b5==0 then b5=b3 end;local b7=aZ.RequireAllOriginal;if b7==nil then b7=aZ.RequireAnyOriginal end;local b8=table.getn(b7)local b9=aZ.Execute;ay.Version=ay.Version+1;if aZ.BeforeExecute~=nil then aZ.BeforeExecute(a_,ay,aZ)end;local ba=aK.Version==0 or aK.Version>b4;local aA=aK.buffers;local bb=aA[av]local bc=table.create(b8)local bd=false;for be,bf in ipairs(b7)do if aA[bf]~=nil then bc[be]=aA[bf]else bc[be]={}end end;local bg={process=a_.process,frame=a_.frame,frameReal=a_.frameReal,delta=a_.delta,deltaExec=b3-b5}for aC=1,aK.Count do if b9(bg,ay,ba,bb[aC],aC,table.unpack(bc))then bd=true end end;if bd then aK.Version=ay.Version end;b6.data[3]=ay.Version;b6.data[4]=b3;b6.key=b6.key+os.clock()-b3;O(E,b6)if os.clock()-b2>b0 then break end;b6=M(b6)end;local bh=X(E)if bh~=nil then self.min_vruntime=math.max(bh.key-b,0)else self.min_vruntime=0 end end;function aU:Update()local E=self.rbtree;local bi=self.Systems;local aX=self.EntityManager;local bj=self.min_vruntime;local bk=self.World.Version;local bl={}local bm={}local aK,aZ;a0(E,function(b6)aK=b6.data[1]aZ=b6.data[2]if bl[aK]==nil then bl[aK]={}end;if bl[aK][aZ]==nil then bl[aK][aZ]={}end;table.insert(bl[aK][aZ],b6)bm[aK]=true end)for af,bn in pairs(bi)do local aP=aX:FilterChunks(bn.Filter.Match)for bo,bp in pairs(aP)do bm[bp]=nil;if bl[bp]==nil then O(E,a4(bj,{bp,bn,bk,0}))elseif bl[bp][bn]==nil then O(E,a4(bj,{bp,bn,bk,0}))end end end;for bq,g in pairs(bm)do for br,b1 in pairs(bl[bq])do for g,b6 in ipairs(b1)do Q(E,b6)end end end end;local function bs(ay,bi)local bt={processIn={},process={},processOut={},transform={},render={}}local bu={processIn={},process={},processOut={},transform={},render={}}local bv={}local bw={}for aD,aZ in pairs(bi)do if aZ.Update~=nil then if bt[aZ.Step][aZ.Order]==nil then bt[aZ.Step][aZ.Order]={}table.insert(bu[aZ.Step],aZ.Order)end;table.insert(bt[aZ.Step][aZ.Order],aZ)end;if aZ.OnEnter~=nil then table.insert(bv,aZ)end;if aZ.OnRemove~=nil then table.insert(bw,aZ)end end;for g,bx in ipairs(bu)do table.sort(bx)end;local by=function(bz,aX,a_,bA)local bB=bt[bz]for af,bx in pairs(bu[bz])do for bo,aZ in pairs(bB[bx])do if aZ.ShouldUpdate==nil or aZ.ShouldUpdate(a_,bA,ay,aZ)then aZ.lastUpdate=a_;local b7=aZ.RequireAllOriginal;if b7==nil then b7=aZ.RequireAnyOriginal end;local b8=table.getn(b7)local bC=aZ.Version;local aP=aX:FilterChunks(aZ.Filter.Match)local bD=aZ.Update;ay.Version=ay.Version+1;if aZ.BeforeUpdate~=nil then aZ.BeforeUpdate(a_,bA,ay,aZ)end;for aD,aK in pairs(aP)do local ba=aK.Version==0 or aK.Version>bC;local aA=aK.Buffers;local bb=aA[av]local bc=table.create(b8)local bd=false;for be,bf in ipairs(b7)do if aA[bf]~=nil then bc[be]=aA[bf]else bc[be]={}end end;for aC=1,aK.Count do if bD(a_,ay,ba,bb[aC],aC,table.unpack(bc))then bd=true end end;if bd then aK.Version=ay.Version end end;if aZ.AfterUpdate~=nil then aZ.AfterUpdate(a_,bA,ay,aZ)end;aZ.Version=ay.Version end end end end;local bE=function(bF,aX,a_)ay.Version=ay.Version+1;for aG,bG in pairs(bF)do local bH=l({RequireAny=bG})local aK,aC=aX:GetEntityChunk(aG)if aK~=nil then local aA=aK.Buffers;for bo,aZ in pairs(bv)do if aZ.Filter.Match(aK.Archetype.Components)then local b7=aZ.RequireAllOriginal;if b7==nil then b7=aZ.RequireAnyOriginal end;if bH.Match(b7)then local bc=table.create(table.getn(b7))for be,bf in ipairs(b7)do if aA[bf]~=nil then bc[be]=aA[bf]else bc[be]={}end end;if aZ.OnEnter(a_,ay,aG,aC,table.unpack(bc))then aK.Version=ay.Version end end end end end end end;local bI=function(bJ,aX,a_)ay.Version=ay.Version+1;for aG,g in pairs(bJ)do local aK,aC=aX:GetEntityChunk(aG)if aK~=nil then local aA=aK.Buffers;for g,aZ in pairs(bw)do if aZ.Filter.Match(aK.Archetype.Components)then local b7=aZ.RequireAllOriginal;if b7==nil then b7=aZ.RequireAnyOriginal end;local bc=table.create(table.getn(b7))for be,bf in ipairs(b7)do if aA[bf]~=nil then bc[be]=aA[bf]else bc[be]={}end end;if aZ.OnRemove(a_,ay,aG,aC,table.unpack(bc))then aK.Version=ay.Version end end end end end end;return by,bE,bI end;local function bK(bi,m)if m==nil then m={}end;local bL=1;local bM={}local bN;local bO,bP,bQ;local bR;local bA=1;local bS=nil;local bT=0;local bU=0;local bV=0;local bW=0;local bX=0;local bY=0;local bZ=10;local b_=0;local aX;local c0;local c1;local c2={}local c3={}local c4={}local c5={}local ay;local c6=false;local function c7()local au=bL;bL=bL+1;c0:Set(au,ag)c2[au]=true;c5[au]=ag;c6=true;return au end;local function c8(aE,aa)if c2[aE]==true then return c0:GetValue(aE,aa)elseif c4[aE]~=nil then return c1:GetValue(aE,aa)else return aX:GetValue(aE,aa)end end;local function c9(aE,aa,...)local az=c5[aE]if az==nil then return end;c6=true;local ca=az:With(aa)local cb=az~=ca;if cb then c5[aE]=ca end;local an;local cc={...}if cc and cc[1]and typeof(cc[1])=='table'and cc[1].__v then an=cc[1].__v[0]else an=ai[aa](table.unpack(cc))end;if c2[aE]==true then if cb then c0:Set(aE,ca)end;c0:SetValue(aE,aa,an)else if cb then if c4[aE]==nil then c4[aE]={received={},lost={}}c1:Set(aE,ca)c1:SetData(aE,aX:GetData(aE))else c1:Set(aE,ca)end end;if c4[aE]~=nil then c1:SetValue(aE,aa,an)local cd=false;for aD,h in pairs(c4[aE].lost)do if h==aa then table.remove(c4[aE].lost,aD)cd=true;break end end;if not cd then table.insert(c4[aE].received,aa)end end;aX:SetValue(aE,aa,an)end end;local function ce(aE,aa,cf,...)local cg=aj[aa][cf]if not cg then return nil end;local ch,an=cg(ay.Get(aE,aa),table.unpack({...}))if ch then ay.Set(aE,aa,{__v={an}})end;return an end;local function ci(aE,aa)local az=c5[aE]if az==nil then return end;if c3[aE]==true then return end;c6=true;if aa==nil then if c2[aE]==true then c0:Remove(aE)c2[aE]=nil;c5[aE]=nil else if c3[aE]==nil then c3[aE]=true end end else local ca=az:Without(aa)local cb=az~=ca;if cb then c5[aE]=ca end;if c2[aE]==true then if cb then c0:Set(aE,ca)end else if cb then if c4[aE]==nil then c4[aE]={received={},lost={}}c1:Set(aE,ca)c1:SetData(aE,aX:GetData(aE))else c1:Set(aE,ca)end end;if c4[aE]~=nil then c1:SetValue(aE,aa,nil)local cd=false;for aD,h in pairs(c4[aE].received)do if h==aa then table.remove(c4[aE].received,aD)cd=true;break end end;if not cd then table.insert(c4[aE].lost,aa)end end;aX:SetValue(aE,aa,nil)end end end;local function cj(aE,aa)if c5[aE]==nil then return false end;return c5[aE]:Has(aa)end;local function ck(cl,a1)local cm=false;local cn=function()cm=true end;local aP=aX:FilterChunks(cl.Match)for aD,aK in pairs(aP)do local aA=aK.Buffers;local bc=table.create(table.getn(cl.Components))for be,bf in ipairs(cl.Components)do if aA[bf]~=nil then bc[be]=aA[bf]else bc[be]={}end end;local bb=aA[av]local bd=false;for aC=1,aK.Count do if a1(cn,bb[aC],aC,table.unpack(bc))then bd=true end;if cm then break end end;if bd then aK.Version=ay.Version end;if cm then break end end end;local function co(aY,bx,m)if aY==nil then return end;if aQ[aY]==nil then error('There is no registered system with the given ID')end;if aQ[aY].Step=='task'then bN:AddSystem(aY)else if bM[aY]~=nil then return end;if aX:Count()>0 or c0:Count()>0 then error('Adding systems is not allowed after adding entities in the world')end;if m==nil then m={}end;local aZ={Id=aY,Name=aQ[aY].Name,RequireAll=aQ[aY].RequireAll,RequireAny=aQ[aY].RequireAny,RequireAllOriginal=aQ[aY].RequireAllOriginal,RequireAnyOriginal=aQ[aY].RequireAnyOriginal,RejectAll=aQ[aY].RejectAll,RejectAny=aQ[aY].RejectAny,Filter=aQ[aY].Filter,OnCreate=aQ[aY].OnCreate,ShouldUpdate=aQ[aY].ShouldUpdate,BeforeUpdate=aQ[aY].BeforeUpdate,Update=aQ[aY].Update,AfterUpdate=aQ[aY].AfterUpdate,OnEnter=aQ[aY].OnEnter,OnRemove=aQ[aY].OnRemove,Step=aQ[aY].Step,Order=aQ[aY].Order,Version=0,LastUpdate=bW,Config=m}if bx~=nil and bx<0 then aZ.Order=50 end;bM[aY]=aZ;b_=0;if aZ.OnCreate~=nil then aZ.OnCreate(ay,aZ)end end end;local function cp(aE)if c5[aE]==nil then return false end;if c2[aE]==true then return false end;if c3[aE]==true then return false end;return true end;local function cq()if ay._steppedConn~=nil then ay._steppedConn:Disconnect()ay._steppedConn=nil end;if ay._heartbeatConn~=nil then ay._heartbeatConn:Disconnect()ay._heartbeatConn=nil end;if ay._renderSteppedConn~=nil then ay._renderSteppedConn:Disconnect()ay._renderSteppedConn=nil end;aX=nil;c0=nil;c1=nil;c4=nil;c3=nil;bM=nil;bO=nil;bP=nil;bQ=nil;c5=nil;bN=nil;ay.Create=nil;ay.Set=nil;ay.Get=nil;ay.Remove=nil;ay.Has=nil;ay.ForEach=nil;ay.AddSystem=nil;ay.Alive=nil;ay.Update=nil;ay.Destroy=nil;ay=nil end;local function cr(a_)if not c6 then return end;c6=false;local cs=false;local bF={}bQ(c3,aX,a_)for aG,ct in pairs(c3)do aX:Remove(aG)c5[aG]=nil;if c4[aG]~=nil then c4[aG]=nil;c1:Remove(aG)end end;c3={}for aG,cu in pairs(c4)do aX:Set(aG,c5[aG])aX:SetData(aG,c1:GetData(aG))c1:Remove(aG)if table.getn(cu.received)>0 then bF[aG]=cu.received;cs=true end end;c4={}for aG,ct in pairs(c2)do aX:Set(aG,c5[aG])aX:SetData(aG,c0:GetData(aG))c0:Remove(aG)bF[aG]=c5[aG].Components;cs=true end;c2={}if cs then bP(bF,aX,a_)bF=nil end end;local function cv(cw)m.Frequency=cw;if m.Frequency==nil then m.Frequency=30 end;local cx=math.round(math.abs(m.Frequency)/2)*2;if cx<2 then cx=2 end;if m.Frequency~=cx then m.Frequency=cx;print(string.format(">>> ATTENTION! The execution frequency of world has been changed to %d <<<",cx))end;bR=1000/m.Frequency/1000;ay.Frequency=m.Frequency end;local function cy(bz,cz)if not a:IsRunning()then return end;if bS==nil then bS=cz end;local cA=cz;cz=cz-bS;if b_<a7 then bO,bP,bQ=bs(ay,bM)b_=a7 end;if bz~='process'then if bW~=bX then bA=1+(cz-bW)/bR else bA=1 end;if bz=='processIn'then bU=cz;bV=cA;if bT==0 then bT=bU end;if bW==0 then bW=bU;bX=bU end;bY=bU-bT;bA=1 elseif bz=='render'then bT=bU end;local a_={process=bW,frame=bU,frameReal=bV,now=cz,nowReal=cA,delta=bY}bO(bz,aX,a_,bA)while c6 do cr(a_)end;if bz=='transform'then bN:Run(a_)cr(a_)end else local cB=bW;local cC=0;local cu=false;while bW<bU and cC<bZ do cu=true;if b_<a7 then bO,bP=bs(ay,bM)b_=a7 end;local a_={process=bW,processDelta=bR,frame=bU,frameReal=bV,now=cz,nowReal=cA,delta=bY}bO(bz,aX,a_,1)while c6 do cr(a_)end;cC=cC+1;bW=bW+bR end;if cu then bX=cB end end end;ay={Version=0,Frequency=m.Frequency,Create=c7,Get=c8,Set=c9,Call=ce,Remove=ci,Has=cj,ForEach=ck,AddSystem=co,Alive=cp,Destroy=cq,Update=cy,SetFrequency=cv}cv(m.Frequency)aX=aF.New(ay)c0=aF.New(ay)c1=aF.New(ay)bN=aU.New(ay,aX)if bi~=nil then for af,aZ in pairs(bi)do co(aZ)end end;if not m.DisableAutoUpdate then ay._steppedConn=a.Stepped:Connect(function()cy('processIn',os.clock())cy('process',os.clock())cy('processOut',os.clock())end)ay._heartbeatConn=a.Heartbeat:Connect(function()cy('transform',os.clock())end)if not a:IsServer()then ay._renderSteppedConn=a.RenderStepped:Connect(function()cy('render',os.clock())end)end end;return ay end;return{RegisterComponent=ap,RegisterSystem=aT,Filter=l,CreateWorld=bK}