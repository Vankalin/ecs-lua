--[[
	Roblox-ECS v1.1

	Roblox-ECS is a tiny and easy to use ECS (Entity Component System) engine for
	game development on the Roblox platform

	This is a minified version of Roblox-ECS, to see the full source code visit
	https://github.com/nidorx/roblox-ecs

	Discussions about this script are at https://devforum.roblox.com/t/841175

	This code was minified using https://goonlinetools.com/lua-minifier/

	------------------------------------------------------------------------------

	MIT License

	Copyright (c) 2020 Alex Rodin

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.
]]
local a=game:GetService('RunService')local function b()return DateTime.now().UnixTimestampMillis end;local c={}local d={}local function e(f)local g=c[f]if g~=nil then if g+1000<b()then print(d[f],' times > ',f)c[f]=b()d[f]=0;return end;d[f]=d[f]+1 else c[f]=b()d[f]=1 end end;local h=0.000000001;local function i(j,k)if j==k then return true end;return math.abs(k-j)<h end;local function l(m,n)if m==n then return true end;if not i(m.X,n.X)or not i(m.Y,n.Y)or not i(m.Z,n.Z)then return false else return true end end;local function o(p)if p==nil then p={}end;local q={}local r={}for s,t in pairs(p)do if t~=nil and q[t]==nil then table.insert(r,t)q[t]=true end end;table.sort(r)return r end;local function u(v)v=o(v)return'_'..table.concat(v,'_'),v end;local w={}local function x(y,z,A,B)local C={}local D,E,F,G;D,y=u(y)E,z=u(z)F,A=u(A)G,B=u(B)return function(H)local I=C[H]if I==false then return false elseif I==true then return true else local J=w[H]if J==nil then J={matchAny={},matchAll={},rejectAny={},rejectAll={}}w[H]=J end;if G~='_'then if J.rejectAny[G]or J.rejectAll[G]then C[H]=false;return false end;for s,t in pairs(B)do if table.find(H,t)then C[H]=false;J.matchAny[G]=true;J.rejectAny[G]=true;return false end end end;if F~='_'then if J.rejectAll[F]then C[H]=false;return false end;local K=true;for s,t in pairs(A)do if not table.find(H,t)then K=false;break end end;if K then C[H]=false;J.matchAll[F]=true;J.rejectAll[F]=true;return false end end;if E~='_'then if J.matchAny[E]or J.matchAll[E]then C[H]=true;return true end;for s,t in pairs(z)do if table.find(H,t)then J.matchAny[E]=true;C[H]=true;return true end end end;if D~='_'then if J.matchAll[D]then C[H]=true;return true end;local K=true;for s,t in pairs(y)do if not table.find(H,t)then K=false;break end end;if K then C[H]=true;J.matchAll[D]=true;J.rejectAll[D]=true;return true end end;C[H]=false;return false end end end;local L={}local M=b()local N={}N.__index=N;function N.get(H)local O;O,H=u(H)if L[O]==nil then L[O]=setmetatable({id=O,components=H},N)M=b()end;return L[O]end;function N:with(P)if table.find(self.components,P)~=nil then return self end;local Q=table.getn(self.components)local R=table.create(Q+1)R[0]=P;table.move(self.components,1,Q,2,R)return N.get(R)end;function N:without(P)if table.find(self.components,P)==nil then return self end;local Q=table.getn(self.components)local R=table.create(Q-1)local S=1;for T=1,Q do if self.components[T]~=P then R[S]=self.components[T]S=S+1 end end;return N.get(R)end;local U=N.get({})local V={}local W={}local X={}local Y={}local function Z(_)return _ end;local a0={register=function(a1,a2,a3)if a1==nil then error('Component name is required for registration')end;if a2~=nil and type(a2)~='function'then error('The component constructor must be a function, or nil')end;if a2==nil then a2=Z end;if a3==nil then a3=false end;if Y[a1]~=nil then error('Another component already registered with that name')end;local a4=table.getn(V)+1;Y[a1]=a4;table.insert(V,a1)table.insert(X,a3)table.insert(W,a2)return a4 end}local a5=a0.register('_ECS_ENTITY_ID_')local a6={}a6.__index=a6;local a7=500;function a6.new(a8,a9)local aa={}aa[a5]=table.create(a7)for s,ab in pairs(a9.components)do if X[ab]then aa[ab]=nil else aa[ab]=table.create(a7)end end;return setmetatable({version=0,count=0,world=a8,archetype=a9,buffers=aa},a6)end;function a6:clear(ac)local aa=self.buffers;for ad in pairs(aa)do aa[ad][ac]=nil end end;function a6:getValue(ac,P)local aa=self.buffers;if aa[P]==nil then return nil end;return aa[P][ac]end;function a6:setValue(ac,P,_)local aa=self.buffers;if aa[P]==nil then return end;aa[P][ac]=_ end;function a6:get(ac)local ae={}local aa=self.buffers;for P in pairs(aa)do ae[P]=aa[P][ac]end;return ae end;function a6:set(ac,ae)local aa=self.buffers;for P,_ in pairs(ae)do if aa[P]~=nil then aa[P][ac]=_ end end end;function a6:setEntityId(ac,af)self.buffers[a5][ac]=af end;local ag={}ag.__index=ag;function ag.new(a8)return setmetatable({world=a8,COUNT=0,ENTITIES={},ARCHETYPES={}},ag)end;function ag:set(ah,a9)local ai=a9.id;local af=self.ENTITIES[ah]local aj=nil;if af~=nil then if af.archetype==ai then return end;aj=self.ARCHETYPES[af.archetype].chunks[af.chunk]:get(af.chunkIndex)self:remove(ah)end;if self.ARCHETYPES[ai]==nil then self.ARCHETYPES[ai]={count=0,lastChunk=1,nextChunkIndex=1,chunks={a6.new(self.world,a9)}}end;local ak=self.ARCHETYPES[ai]self.ENTITIES[ah]={archetype=ai,chunk=ak.lastChunk,chunkIndex=ak.nextChunkIndex}self.COUNT=self.COUNT+1;local al=ak.chunks[ak.lastChunk]al:clear(ak.nextChunkIndex)if aj~=nil then al:set(ak.nextChunkIndex,aj)end;al:setEntityId(ak.nextChunkIndex,ah)ak.count=ak.count+1;al.count=ak.nextChunkIndex;ak.nextChunkIndex=ak.nextChunkIndex+1;al.version=self.world.version;if ak.nextChunkIndex>a7 then ak.lastChunk=ak.lastChunk+1;ak.nextChunkIndex=1;ak.chunks[ak.lastChunk]=a6.new(self.world,a9)end end;function ag:remove(ah)local af=self.ENTITIES[ah]if af==nil then return end;local ak=self.ARCHETYPES[af.archetype]local al=ak.chunks[af.chunk]al:clear(af.chunkIndex)al.count=al.count-1;self.ENTITIES[ah]=nil;self.COUNT=self.COUNT-1;ak.count=ak.count-1;if ak.nextChunkIndex==1 then ak.chunks[ak.lastChunk]=nil;ak.lastChunk=ak.lastChunk-1;ak.nextChunkIndex=a7+1 end;if ak.count>0 then if ak.nextChunkIndex>1 then local am=ak.chunks[ak.lastChunk]:get(ak.nextChunkIndex-1)ak.chunks[af.chunk]:set(af.chunkIndex,am)ak.nextChunkIndex=ak.nextChunkIndex-1;ak.chunks[ak.lastChunk]:clear(ak.nextChunkIndex)local an=am[a5]local ao=self.ENTITIES[an]ao.chunk=af.chunk;ao.chunkIndex=af.chunkIndex end else ak.nextChunkIndex=ak.nextChunkIndex-1 end end;function ag:count()return self.COUNT end;function ag:clear(ah)local af=self.ENTITIES[ah]if af==nil then return end;local al=self.ARCHETYPES[af.archetype].chunks[af.chunk]al:clear(af.chunkIndex)end;function ag:getValue(ah,P)local af=self.ENTITIES[ah]if af==nil then return nil end;return self.ARCHETYPES[af.archetype].chunks[af.chunk]:getValue(af.chunkIndex,P)end;function ag:setValue(ah,P,_)local af=self.ENTITIES[ah]if af==nil then return end;local al=self.ARCHETYPES[af.archetype].chunks[af.chunk]al:setValue(af.chunkIndex,P,_)end;function ag:getData(ah)local af=self.ENTITIES[ah]if af==nil then return nil end;local al=self.ARCHETYPES[af.archetype].chunks[af.chunk]return al:get(af.chunkIndex)end;function ag:setData(ah,P,ae)local af=self.ENTITIES[ah]if af==nil then return end;local al=self.ARCHETYPES[af.archetype].chunks[af.chunk]al:set(af.chunkIndex,P,ae)end;function ag:getEntityChunk(ah)local af=self.ENTITIES[ah]if af==nil then return end;return self.ARCHETYPES[af.archetype].chunks[af.chunk],af.chunkIndex end;function ag:filterChunks(ap)local aq={}for ai,ak in pairs(self.ARCHETYPES)do if ap(L[ai].components)then for T,al in pairs(ak.chunks)do table.insert(aq,al)end end end;return aq end;local ar={}local as={}local at={}function at.register(au)if au==nil then error('System configuration is required for its creation')end;if au.name==nil then error('The system "name" is required for registration')end;if as[au.name]~=nil then error('Another System already registered with that name')end;if au.requireAll==nil and au.requireAny==nil then error('It is necessary to define the components using the "requireAll" or "requireAny" parameters')end;if au.requireAll~=nil and au.requireAny~=nil then error('It is not allowed to use the "requireAll" and "requireAny" settings simultaneously')end;if au.requireAll~=nil then au.requireAllOriginal=au.requireAll;au.requireAll=o(au.requireAll)if table.getn(au.requireAll)==0 then error('You must enter at least one component id in the "requireAll" field')end elseif au.requireAny~=nil then au.requireAnyOriginal=au.requireAny;au.requireAny=o(au.requireAny)if table.getn(au.requireAny)==0 then error('You must enter at least one component id in the "requireAny" field')end end;if au.rejectAll~=nil and au.rejectAny~=nil then error('It is not allowed to use the "rejectAll" and "rejectAny" settings simultaneously')end;if au.rejectAll~=nil then au.rejectAll=o(au.rejectAll)if table.getn(au.rejectAll)==0 then error('You must enter at least one component id in the "rejectAll" field')end elseif au.rejectAny~=nil then au.rejectAny=o(au.rejectAny)if table.getn(au.rejectAny)==0 then error('You must enter at least one component id in the "rejectAny" field')end end;if au.step==nil then au.step='transform'end;if au.step~='render'and au.step~='process'and au.step~='processIn'and au.step~='processOut'and au.step~='transform'then error('The "step" parameter must be "render", "process", "transform", "processIn" or "processOut"')end;if au.order==nil or au.order<0 then au.order=50 end;table.insert(ar,{name=au.name,requireAll=au.requireAll,requireAny=au.requireAny,requireAllOriginal=au.requireAllOriginal,requireAnyOriginal=au.requireAnyOriginal,rejectAll=au.rejectAll,rejectAny=au.rejectAny,beforeUpdate=au.beforeUpdate,update=au.update,onEnter=au.onEnter,step=au.step,order=au.order})local a4=table.getn(ar)as[au.name]=a4;return a4 end;local function av(a8,aw)local ax={render={},process={},transform={},processIn={},processOut={}}local ay={}for ad,az in pairs(aw)do az.filter=x(az.requireAll,az.requireAny,az.rejectAll,az.rejectAny)if az.update~=nil then if ax[az.step][az.order]==nil then ax[az.step][az.order]={}end;table.insert(ax[az.step][az.order],az)end;if az.onEnter~=nil then table.insert(ay,az)end end;local aA=function(aB,aC,aD,aE)for T,aF in pairs(ax[aB])do for aG,az in pairs(aF)do az.lastUpdate=aD;local aH=az.requireAllOriginal;if aH==nil then aH=az.requireAnyOriginal end;local aI=table.getn(aH)local aJ=az.version;local aq=aC:filterChunks(az.filter)local aK=az.update;a8.version=a8.version+1;if az.beforeUpdate~=nil then az.beforeUpdate(aD,aE,a8,az)end;for ad,al in pairs(aq)do local aL=al.version==0 or al.version>aJ;local aa=al.buffers;local aM=aa[a5]local aN=table.create(aI)local aO=false;for aP,aQ in ipairs(aH)do if aa[aQ]~=nil then aN[aP]=aa[aQ]else aN[aP]={}end end;for ac=1,al.count do if aK(aD,a8,aL,aM[ac],ac,table.unpack(aN))then aO=true end end;if aO then al.version=a8.version end end;az.version=a8.version end end end;local aR=function(aS,aC,aD)a8.version=a8.version+1;local aT={}for ah,aU in pairs(aS)do local al,ac=aC:getEntityChunk(ah)if al~=nil then local aa=al.buffers;for aG,az in pairs(ay)do if az.filter(al.archetype.components)then local aH=az.requireAllOriginal;if aH==nil then aH=az.requireAnyOriginal end;if aT[az.id]==nil then aT[az.id]=x(nil,aU,nil,nil)end;if aT[az.id](aH)then local aN=table.create(table.getn(aH))for aP,aQ in ipairs(aH)do if aa[aQ]~=nil then aN[aP]=aa[aQ]else aN[aP]={}end end;if az.onEnter(aD,a8,ah,ac,table.unpack(aN))then al.version=a8.version end end end end end end end;return aA,aR end;local aV={Component=a0,System=at}function aV.newWorld(aw,au)if au==nil then au={}end;if au.frequency==nil then au.frequency=30 end;local aW=math.round(math.abs(au.frequency)/5)*5;if aW<5 then aW=5 end;if au.frequency~=aW then au.frequency=aW;print(string.format(">>> ATTENTION! The execution frequency of world has been changed to %d <<<",aW))end;local aX=1;local aY={}local aZ,a_;local b0=1000/au.frequency/1000;local aE=1;local b1=nil;local b2=0;local b3=0;local b4=0;local b5=0;local b6=0;local b7=10;local b8=0;local aC;local b9;local ba;local bb={}local bc={}local bd={}local be={}local a8;local bf;local bg=false;a8={version=0,frequency=au.frequency,create=function()local a4=aX;aX=aX+1;b9:set(a4,U)bd[a4]=true;be[a4]=U;bg=true;return a4 end,get=function(af,P)if bd[af]==true then return b9:getValue(af,P)else return aC:getValue(af,P)end end,set=function(af,P,...)local a9=be[af]if a9==nil then return end;bg=true;local bh=a9:with(P)local bi=a9~=bh;if bi then be[af]=bh end;local _=W[P](table.unpack({...}))if bd[af]==true then if bi then b9:set(af,bh)end;b9:setValue(af,P,_)else if bi then if bc[af]==nil then bc[af]={received={},lost={}}ba:set(af,bh)ba:setData(af,aC:getData(af))else ba:set(af,bh)end end;if bc[af]~=nil then ba:setValue(af,P,_)local bj=false;for ad,t in pairs(bc[af].lost)do if t==P then table.remove(bc[af].lost,ad)bj=true;break end end;if not bj then table.insert(bc[af].received,P)end end;aC:setValue(af,P,_)end end,remove=function(af,P)local a9=be[af]if a9==nil then return end;if bb[af]==true then return end;bg=true;if P==nil then if bd[af]==true then b9:remove(af)bd[af]=nil;be[af]=nil else if bb[af]==nil then bb[af]=true end end else local bh=a9:without(P)local bi=a9~=bh;if bi then be[af]=bh end;if bd[af]==true then if bi then b9:set(af,bh)end else if bi then if bc[af]==nil then bc[af]={received={},lost={}}ba:set(af,bh)ba:setData(af,aC:getData(af))else ba:set(af,bh)end end;if bc[af]~=nil then ba:setValue(af,P,nil)local bj=false;for ad,t in pairs(bc[af].received)do if t==P then table.remove(bc[af].received,ad)bj=true;break end end;if not bj then table.insert(bc[af].lost,P)end end;aC:setValue(af,P,nil)end end end,has=function(af,P)if be[af]==nil then return false end;return be[af]:has(P)end,addSystem=function(bk,bl,au)if bk==nil then return end;if ar[bk]==nil then error('There is no registered system with the given ID')end;if aY[bk]~=nil then return end;if aC:count()>0 or b9:count()>0 then error('Adding systems is not allowed after adding entities in the world')end;if au==nil then au={}end;local az={id=bk,name=ar[bk].name,requireAll=ar[bk].requireAll,requireAny=ar[bk].requireAny,requireAllOriginal=ar[bk].requireAllOriginal,requireAnyOriginal=ar[bk].requireAnyOriginal,rejectAll=ar[bk].rejectAll,rejectAny=ar[bk].rejectAny,beforeUpdate=ar[bk].beforeUpdate,update=ar[bk].update,onEnter=ar[bk].onEnter,step=ar[bk].step,order=ar[bk].order,version=0,lastUpdate=b4,config=au}if bl~=nil and bl<0 then az.order=50 end;aY[bk]=az;b8=0 end,alive=function(af)if be[af]==nil then return false end;if bd[af]==true then return false end;if bb[af]==true then return false end;return true end,destroy=function()end,update=function(aB,bm)if not a:IsRunning()then return end;if b1==nil then b1=bm end;bm=bm-b1;if b8<M then aZ,a_=av(a8,aY)b8=M end;if aB~='process'then if b4~=b5 then aE=1+(bm-b4)/b0 else aE=1 end;if aB=='processIn'then b3=bm;if b2==0 then b2=b3 end;if b4==0 then b4=b3;b5=b3 end;b6=b3-b2;aE=1 elseif aB=='render'then b2=b3 end;aZ(aB,aC,{process=b4,frame=b3,delta=b6},aE)while bg do bf()end else local bn=b4;local bo=0;local bp=false;while b4<b3 and bo<b7 do bp=true;if b8<M then aZ,a_=av(a8,aY)b8=M end;aZ(aB,aC,{process=b4,frame=b3,delta=b6},1)while bg do bf()end;bo=bo+1;b4=b4+b0 end;if bp then b5=bn end end end}bf=function()if not bg then return end;bg=false;for ah,bq in pairs(bb)do aC:remove(ah)be[ah]=nil;if bc[ah]~=nil then bc[ah]=nil;ba:remove(ah)end end;local br=false;local aS={}for ah,bp in pairs(bc)do aC:set(ah,be[ah])aC:setData(ah,ba:getData(ah))ba:remove(ah)if table.getn(bp.received)>0 then aS[ah]=bp.received;br=true end end;bc={}for ah,bq in pairs(bd)do aC:set(ah,be[ah])aC:setData(ah,b9:getData(ah))b9:remove(ah)aS[ah]=be[ah].components;br=true end;bd={}if br then a_(aS,aC)aS=nil end end;aC=ag.new(a8)b9=ag.new(a8)ba=ag.new(a8)if aw~=nil then for T,az in pairs(aw)do a8.addSystem(az)end end;if not au.disableDefaultSystems then a8.addSystem(aV.Util.BasePartToEntityProcessInSystem)a8.addSystem(aV.Util.MoveForwardSystem)a8.addSystem(aV.Util.EntityToBasePartProcessOutSystem)a8.addSystem(aV.Util.BasePartToEntityTransformSystem)a8.addSystem(aV.Util.EntityToBasePartTransformSystem)a8.addSystem(aV.Util.EntityToBasePartInterpolationTransformSystem)end;if not au.disableAutoUpdate then a8._steppedConn=a.Stepped:Connect(function()a8.update('processIn',tick())a8.update('process',tick())a8.update('processOut',tick())end)a8._heartbeatConn=a.Heartbeat:Connect(function()a8.update('transform',tick())end)a8._renderSteppedConn=a.RenderStepped:Connect(function()a8.update('render',tick())end)end;return a8 end;aV.Util={}function aV.Util.NewBasePartEntity(a8,bs,bt,bu,bv)local ah=a8.create()a8.set(ah,aV.Util.BasePartComponent,bs)a8.set(ah,aV.Util.PositionComponent,bs.CFrame.Position)a8.set(ah,aV.Util.RotationComponent,bs.CFrame.RightVector,bs.CFrame.UpVector,bs.CFrame.LookVector)if bt then a8.set(ah,aV.Util.BasePartToEntitySyncComponent)end;if bu then a8.set(ah,aV.Util.EntityToBasePartSyncComponent)end;if bv then a8.set(ah,aV.Util.PositionInterpolationComponent,bs.CFrame.Position)a8.set(ah,aV.Util.RotationInterpolationComponent,bs.CFrame.RightVector,bs.CFrame.UpVector,bs.CFrame.LookVector)end;return ah end;aV.Util.BasePartComponent=a0.register('BasePart',function(bw)if bw==nil or bw['IsA']==nil or bw:IsA('BasePart')==false then error("This component only works with BasePart objects")end;return bw end)aV.Util.BasePartToEntitySyncComponent=a0.register('BasePartToEntitySync',nil,true)aV.Util.EntityToBasePartSyncComponent=a0.register('EntityToBasePartSync',nil,true)aV.Util.PositionComponent=a0.register('Position',function(bx)if bx~=nil and typeof(bx)~='Vector3'then error("This component only works with Vector3 objects")end;if bx==nil then bx=Vector3.new(0,0,0)end;return bx end)aV.Util.PositionInterpolationComponent=a0.register('PositionInterpolation',function(bx)if bx~=nil and typeof(bx)~='Vector3'then error("This component only works with Vector3 objects")end;if bx==nil then bx=Vector3.new(0,0,0)end;return{bx,bx}end)local by=Vector3.new(1,0,0)local bz=Vector3.new(0,1,0)local bA=Vector3.new(0,0,1)aV.Util.RotationComponent=a0.register('Rotation',function(bB,bC,bD)if bB~=nil and typeof(bB)~='Vector3'then error("This component only works with Vector3 objects [param=rightVector]")end;if bC~=nil and typeof(bC)~='Vector3'then error("This component only works with Vector3 objects [param=upVector]")end;if bD~=nil and typeof(bD)~='Vector3'then error("This component only works with Vector3 objects [param=lookVector]")end;if bB==nil then bB=by end;if bC==nil then bC=bz end;if bD==nil then bD=bA end;return{bB,bC,bD}end)aV.Util.RotationInterpolationComponent=a0.register('RotationInterpolation',function(bB,bC,bD)if bB~=nil and typeof(bB)~='Vector3'then error("This component only works with Vector3 objects [param=rightVector]")end;if bC~=nil and typeof(bC)~='Vector3'then error("This component only works with Vector3 objects [param=upVector]")end;if bD~=nil and typeof(bD)~='Vector3'then error("This component only works with Vector3 objects [param=lookVector]")end;if bB==nil then bB=by end;if bC==nil then bC=bz end;if bD==nil then bD=bA end;return{{bB,bC,bD},{bB,bC,bD}}end)aV.Util.MoveForwardComponent=a0.register('MoveForward',nil,true)aV.Util.MoveSpeedComponent=a0.register('MoveSpeed',function(bE)if bE==nil or typeof(bE)~='number'then error("This component only works with number value")end;return bE end)local function bF(aD,a8,aL,af,ac,bG,bH,bI)local bJ=false;local bs=bG[ac]if bs~=nil then local bx=bH[ac]local bK=bs.CFrame.Position;if bx==nil or not l(bK,bx)then bH[ac]=bK;bJ=true end;local bL=bI[ac]local bB=bs.CFrame.RightVector;local bC=bs.CFrame.UpVector;local bD=bs.CFrame.LookVector;if bL==nil or not l(bB,bL[1])or not l(bC,bL[2])or not l(bD,bL[3])then bI[ac]={bB,bC,bD}bJ=true end end;return bJ end;aV.Util.BasePartToEntityProcessInSystem=at.register({name='BasePartToEntityProcessIn',step='processIn',order=10,requireAll={aV.Util.BasePartComponent,aV.Util.PositionComponent,aV.Util.RotationComponent,aV.Util.BasePartToEntitySyncComponent},rejectAny={aV.Util.PositionInterpolationComponent,aV.Util.RotationInterpolationComponent},update=bF})aV.Util.BasePartToEntityTransformSystem=at.register({name='BasePartToEntityTransform',step='transform',order=10,requireAll={aV.Util.BasePartComponent,aV.Util.PositionComponent,aV.Util.RotationComponent,aV.Util.BasePartToEntitySyncComponent},rejectAny={aV.Util.PositionInterpolationComponent,aV.Util.RotationInterpolationComponent},update=bF})local function bM(aD,a8,aL,af,ac,bG,bH,bI)if not aL then return false end;local bJ=false;local bs=bG[ac]local bx=bH[ac]local bL=bI[ac]if bs~=nil then local bK=bs.CFrame.Position;local bB=bs.CFrame.RightVector;local bC=bs.CFrame.UpVector;local bD=bs.CFrame.LookVector;local bN=bs.CFrame;if bx~=nil and not l(bK,bx)then bN=CFrame.fromMatrix(bx,bB,bC,bD*-1)bJ=true end;if bL~=nil then if not l(bB,bL[1])or not l(bC,bL[2])or not l(bD,bL[3])then bN=CFrame.fromMatrix(bN.Position,bL[1],bL[2],bL[3]*-1)bJ=true end end;if bJ then bs.CFrame=bN end end;return bJ end;aV.Util.EntityToBasePartProcessOutSystem=at.register({name='EntityToBasePartProcess',step='processOut',order=100,requireAll={aV.Util.BasePartComponent,aV.Util.PositionComponent,aV.Util.RotationComponent,aV.Util.EntityToBasePartSyncComponent},update=bM})aV.Util.EntityToBasePartTransformSystem=at.register({name='EntityToBasePartTransform',step='transform',order=100,requireAll={aV.Util.BasePartComponent,aV.Util.PositionComponent,aV.Util.RotationComponent,aV.Util.EntityToBasePartSyncComponent},rejectAny={aV.Util.PositionInterpolationComponent,aV.Util.RotationInterpolationComponent},update=bM})local bO=1;aV.Util.EntityToBasePartInterpolationTransformSystem=at.register({name='EntityToBasePartInterpolationTransform',step='transform',order=100,requireAll={aV.Util.BasePartComponent,aV.Util.PositionComponent,aV.Util.RotationComponent,aV.Util.PositionInterpolationComponent,aV.Util.RotationInterpolationComponent,aV.Util.EntityToBasePartSyncComponent},beforeUpdate=function(aD,aE,a8,az)bO=aE end,update=function(aD,a8,aL,af,ac,bG,bH,bI,bP,bQ)local bs=bG[ac]local bx=bH[ac]local bL=bI[ac]if bs~=nil then local bN=bs.CFrame;if bx~=nil then local bB=bs.CFrame.RightVector;local bC=bs.CFrame.UpVector;local bD=bs.CFrame.LookVector;if not l(bP[ac][1],bx)then bP[ac][2]=bP[ac][1]bP[ac][1]=bx end;local bR=bP[ac][2]bN=CFrame.fromMatrix(bR:Lerp(bx,bO),bB,bC,bD*-1)end;if bL~=nil then if not l(bQ[ac][1][1],bL[1])or not l(bQ[ac][1][2],bL[2])or not l(bQ[ac][1][3],bL[3])then bQ[ac][2]=bQ[ac][1]bQ[ac][1]=bL end;local bS=bQ[ac][2]bN=CFrame.fromMatrix(bN.Position,bS[1]:Lerp(bL[1],bO),bS[2]:Lerp(bL[2],bO),(bS[3]*-1):Lerp(bL[3]*-1,bO))end;bs.CFrame=bN end;return false end})local bT=1;aV.Util.MoveForwardSystem=at.register({name='MoveForward',step='process',requireAll={aV.Util.MoveSpeedComponent,aV.Util.PositionComponent,aV.Util.RotationComponent,aV.Util.MoveForwardComponent},beforeUpdate=function(aD,aE,a8,az)bT=a8.frequency/60 end,update=function(aD,a8,aL,af,ac,bU,bH,bI,bV)local bx=bH[ac]if bx~=nil then local bL=bI[ac]if bL~=nil then local bE=bU[ac]if bE~=nil then bH[ac]=bx+bE/bT*bL[3]return true end end end;return false end})return aV