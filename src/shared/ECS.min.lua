--[[
	Roblox-ECS v1.2.2 [2021-02-22 15:55]

	Roblox-ECS is a tiny and easy to use ECS (Entity Component System) engine for
	game development on the Roblox platform

	This is a minified version of Roblox-ECS, to see the full source code visit
	https://github.com/nidorx/roblox-ecs

	Discussions about this script are at https://devforum.roblox.com/t/841175

	------------------------------------------------------------------------------

	MIT License

	Copyright (c) 2020 Alex Rodin

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.
]]
local a=game:GetService('RunService')local b=0.000000001;local function c(d)if d==nil then d={}end;local e={}local f={}for g,h in pairs(d)do if h~=nil and e[h]==nil then table.insert(f,h)e[h]=true end end;table.sort(f)return f end;local function i(j)j=c(j)return'_'..table.concat(j,'_'),j end;local k={}local function l(m)local n={}if m==nil then m={}end;if m.RequireAll==nil and m.RequireAny==nil then error('It is necessary to define the components using the "RequireAll" or "RequireAny" parameters')end;if m.RequireAll~=nil and m.RequireAny~=nil then error('It is not allowed to use the "RequireAll" and "RequireAny" settings simultaneously')end;if m.RequireAll~=nil then m.RequireAllOriginal=m.RequireAll;m.RequireAll=c(m.RequireAll)if table.getn(m.RequireAll)==0 then error('You must enter at least one component id in the "RequireAll" field')end elseif m.RequireAny~=nil then m.RequireAnyOriginal=m.RequireAny;m.RequireAny=c(m.RequireAny)if table.getn(m.RequireAny)==0 then error('You must enter at least one component id in the "RequireAny" field')end end;if m.RejectAll~=nil and m.RejectAny~=nil then error('It is not allowed to use the "RejectAll" and "RejectAny" settings simultaneously')end;if m.RejectAll~=nil then m.RejectAll=c(m.RejectAll)if table.getn(m.RejectAll)==0 then error('You must enter at least one component id in the "RejectAll" field')end elseif m.RejectAny~=nil then m.RejectAny=c(m.RejectAny)if table.getn(m.RejectAny)==0 then error('You must enter at least one component id in the "RejectAny" field')end end;local o,p=i(m.RequireAll)local q,r=i(m.RequireAny)local s,t=i(m.RejectAll)local u,v=i(m.RejectAny)local w=m.RequireAllOriginal;if w==nil then w=m.RequireAnyOriginal end;return{Components=w,Match=function(w)local x=n[w]if x==false then return false elseif x==true then return true else local y=k[w]if y==nil then y={MatchAny={},MatchAll={},RejectAny={},RejectAll={}}k[w]=y end;if u~='_'then if y.RejectAny[u]or y.RejectAll[u]then n[w]=false;return false end;for g,h in pairs(v)do if table.find(w,h)then n[w]=false;y.MatchAny[u]=true;y.RejectAny[u]=true;return false end end end;if s~='_'then if y.RejectAll[s]then n[w]=false;return false end;local z=true;for g,h in pairs(t)do if not table.find(w,h)then z=false;break end end;if z then n[w]=false;y.MatchAll[s]=true;y.RejectAll[s]=true;return false end end;if q~='_'then if y.MatchAny[q]or y.MatchAll[q]then n[w]=true;return true end;for g,h in pairs(r)do if table.find(w,h)then y.MatchAny[q]=true;n[w]=true;return true end end end;if o~='_'then if y.MatchAll[o]then n[w]=true;return true end;local z=true;for g,h in pairs(p)do if not table.find(w,h)then z=false;break end end;if z then n[w]=true;y.MatchAll[o]=true;y.RejectAll[o]=true;return true end end;n[w]=false;return false end end}end;local A=0;local B=1;local C={key=0,color=A}local function D(E,F)local G=F.right;F.right=G.left;if G.left~=C then G.left.parent=F end;G.parent=F.parent;if F.parent==C then E.root=G elseif F==F.parent.left then F.parent.left=G else F.parent.right=G end;G.left=F;F.parent=G end;local function H(E,F)local I=F.left;F.left=I.right;if I.right~=C then I.right.parent=F end;I.parent=F.parent;if F.parent==C then E.root=I elseif F==F.parent.right then F.parent.right=I else F.parent.left=I end;I.right=F;F.parent=I end;local function J(E,F,K)if F.parent==C then E.root=K elseif F==F.parent.left then F.parent.left=K else F.parent.right=K end;K.parent=F.parent end;local function L(F)while F.left~=C do F=F.left end;return F end;local function M(F)if F==C then return nil end;if F.parent==F then return nil end;if F.right~=C then return L(F.right)end;local N;while true do N=F.parent;if N==C then return nil end;if F==N.right then F=N else break end end;return N end;local function O(E,F)local N=C;local P=E.root;while P~=C do N=P;if F.key<P.key then P=P.left else P=P.right end end;F.parent=N;if N==C then E.root=F elseif F.key<N.key then N.left=F else N.right=F end;F.left=C;F.right=C;F.color=B;while F.parent.color==B do if F.parent==F.parent.parent.left then N=F.parent.parent.right;if N.color==B then F.parent.color=A;N.color=A;F.parent.parent.color=B;F=F.parent.parent else if F==F.parent.right then F=F.parent;D(E,F)end;F.parent.color=A;F.parent.parent.color=B;H(E,F.parent.parent)end else N=F.parent.parent.left;if N.color==B then F.parent.color=A;N.color=A;F.parent.parent.color=B;F=F.parent.parent else if F==F.parent.left then F=F.parent;H(E,F)end;F.parent.color=A;F.parent.parent.color=B;D(E,F.parent.parent)end end end;E.root.color=A end;local function Q(E,F)if F==C then return end;local R,S;local T=F.color;if F.left==C then R=F.right;J(E,F,F.right)elseif F.right==C then R=F.left;J(E,F,F.left)else local U=L(F.right)T=U.color;R=U.right;if U.parent==F then R.parent=U else J(E,U,U.right)U.right=F.right;U.right.parent=U end;J(E,F,U)U.left=F.left;U.left.parent=U;U.color=F.color end;if T~=A then return end;while R~=E.root and R.color==A do if R==R.parent.left then S=R.parent.right;if S.color==B then S.color=A;R.parent.color=B;D(E,R.parent)S=R.parent.right end;if S.left.color==A and S.right.color==A then S.color=B;R=R.parent else if S.right.color==A then S.left.color=A;S.color=B;H(E,S)S=R.parent.right end;S.color=R.parent.color;R.parent.color=A;S.right.color=A;D(E,R.parent)R=E.root end else S=R.parent.left;if S.color==B then S.color=A;R.parent.color=B;H(E,R.parent)S=R.parent.left end;if S.right.color==A and S.left.color==A then S.color=B;R=R.parent else if S.left.color==A then S.right.color=A;S.color=B;D(E,S)S=R.parent.left end;S.color=R.parent.color;R.parent.color=A;S.left.color=A;H(E,R.parent)R=E.root end end end;R.color=A end;local function V(E,W)local F=E.root;while F~=C and W~=F.key do if W<F.key then F=F.left else F=F.right end end;return F end;local function X(E)if E.root==C then return nil end;return L(E.root)end;local function Y(E,Z)local _={}local F=X(E)while F~=nil do if Z(F)then table.insert(_,F)end;F=M(F)end;return _ end;local function a0(E,a1)local F=X(E)while F~=nil do a1(F)F=M(F)end end;local function a2(E)local _={}local F=X(E)while F~=nil do table.insert(_,F)F=M(F)end;return _ end;local function a3()return{root=C,count=0}end;local function a4(W,a5)return{key=W,data=a5}end;local a6={}local a7=os.clock()local a8={}a8.__index=a8;function a8.Get(w)local a9;a9,w=i(w)if a6[a9]==nil then a6[a9]=setmetatable({Id=a9,Components=w},a8)a7=os.clock()end;return a6[a9]end;function a8:With(aa)local ab=self.Components;if table.find(ab,aa)~=nil then return self end;local ac=table.getn(ab)local ad=table.create(ac+1)ad[0]=aa;table.move(ab,1,ac,2,ad)return a8.Get(ad)end;function a8:WithAll(w)local ae=self;for g,aa in ipairs(w)do ae=ae:With(aa)end;return ae end;function a8:Without(aa)local ab=self.Components;if table.find(ab,aa)==nil then return self end;local ac=table.getn(ab)local ad=table.create(ac-1)local af=1;for ag=1,ac do if ab[ag]~=aa then ad[af]=ab[ag]af=af+1 end end;return a8.Get(ad)end;function a8:WithoutAll(w)local ae=self;for g,aa in ipairs(w)do ae=ae:Without(aa)end;return ae end;function a8:Has(aa)return table.find(self.Components,aa)~=nil end;local ah=a8.Get({})local ai={}local aj={}local ak={}local al={}local am={}local function an(ao)return ao end;local ap={}local function aq(ar,as,at,au)if ar==nil then error('Component name is required for registration')end;if as~=nil and type(as)~='function'then error('The component constructor must be a function, or nil')end;if as==nil then as=an end;if at==nil then at=false end;if au==nil then au=ap end;if am[ar]~=nil then error('Another component already registered with that name')end;local av=table.getn(ai)+1;am[ar]=av;table.insert(ai,ar)table.insert(ak,au)table.insert(al,at)table.insert(aj,as)return av end;local aw=aq('_ECS_ENTITY_ID_')local ax={}ax.__index=ax;local ay=10;function ax.New(az,aA)local aB={}aB[aw]=table.create(ay)for g,aC in pairs(aA.Components)do if al[aC]then aB[aC]=nil else aB[aC]=table.create(ay)end end;return setmetatable({Version=0,Count=0,World=az,Archetype=aA,Buffers=aB},ax)end;function ax:Clear(aD)local aB=self.Buffers;for aE in pairs(aB)do aB[aE][aD]=nil end end;function ax:GetValue(aD,aa)local aB=self.Buffers;if aB[aa]==nil then return nil end;return aB[aa][aD]end;function ax:SetValue(aD,aa,ao)local aB=self.Buffers;if aB[aa]==nil then return end;aB[aa][aD]=ao end;function ax:Get(aD)local a5={}local aB=self.Buffers;for aa in pairs(aB)do a5[aa]=aB[aa][aD]end;return a5 end;function ax:Set(aD,a5)local aB=self.Buffers;for aa,ao in pairs(a5)do if aB[aa]~=nil then aB[aa][aD]=ao end end end;function ax:SetEntityId(aD,aF)self.Buffers[aw][aD]=aF end;local aG={}aG.__index=aG;function aG.New(az)return setmetatable({World=az,Version=0,CountValue=0,Entities={},Archetypes={}},aG)end;function aG:Set(aH,aA)local aI=aA.Id;local aF=self.Entities[aH]local aJ=nil;if aF~=nil then if aF.Archetype==aI then return end;aJ=self.Archetypes[aF.Archetype].Chunks[aF.Chunk]:Get(aF.ChunkIndex)self:Remove(aH)end;if self.Archetypes[aI]==nil then self.Archetypes[aI]={Count=0,LastChunk=1,NextChunkIndex=1,Chunks={ax.New(self.World,aA)}}self.Version=self.Version+1 end;local aK=self.Archetypes[aI]self.Entities[aH]={Archetype=aI,Chunk=aK.LastChunk,ChunkIndex=aK.NextChunkIndex}self.CountValue=self.CountValue+1;local aL=aK.Chunks[aK.LastChunk]aL:Clear(aK.NextChunkIndex)if aJ~=nil then aL:Set(aK.NextChunkIndex,aJ)end;aL:SetEntityId(aK.NextChunkIndex,aH)aK.Count=aK.Count+1;aL.Count=aK.NextChunkIndex;aK.NextChunkIndex=aK.NextChunkIndex+1;aL.Version=self.World.Version;if aK.NextChunkIndex>ay then aK.LastChunk=aK.LastChunk+1;aK.NextChunkIndex=1;aK.Chunks[aK.LastChunk]=ax.New(self.World,aA)self.Version=self.Version+1 end end;function aG:Remove(aH)local aF=self.Entities[aH]if aF==nil then return end;local aK=self.Archetypes[aF.Archetype]local aL=aK.Chunks[aF.Chunk]aL:Clear(aF.ChunkIndex)aL.Count=aL.Count-1;self.Entities[aH]=nil;self.CountValue=self.CountValue-1;aK.Count=aK.Count-1;if aK.NextChunkIndex==1 then aK.Chunks[aK.LastChunk]=nil;aK.LastChunk=aK.LastChunk-1;aK.NextChunkIndex=ay+1;self.Version=self.Version+1 end;if aK.Count>0 then if aK.NextChunkIndex>1 then if not(aK.LastChunk==aF.Chunk and aK.NextChunkIndex-1==aF.ChunkIndex)then local aM=aK.Chunks[aK.LastChunk]:Get(aK.NextChunkIndex-1)aK.Chunks[aF.Chunk]:Set(aF.ChunkIndex,aM)local aN=aM[aw]local aO=self.Entities[aN]aO.Chunk=aF.Chunk;aO.ChunkIndex=aF.ChunkIndex end;aK.NextChunkIndex=aK.NextChunkIndex-1;aK.Chunks[aK.LastChunk]:Clear(aK.NextChunkIndex)end else aK.NextChunkIndex=aK.NextChunkIndex-1 end end;function aG:Count()return self.CountValue end;function aG:Clear(aH)local aF=self.Entities[aH]if aF==nil then return end;local aL=self.Archetypes[aF.Archetype].Chunks[aF.Chunk]aL:Clear(aF.ChunkIndex)end;function aG:GetValue(aH,aa)local aF=self.Entities[aH]if aF==nil then return nil end;return self.Archetypes[aF.Archetype].Chunks[aF.Chunk]:GetValue(aF.ChunkIndex,aa)end;function aG:SetValue(aH,aa,ao)local aF=self.Entities[aH]if aF==nil then return end;local aL=self.Archetypes[aF.Archetype].Chunks[aF.Chunk]aL:SetValue(aF.ChunkIndex,aa,ao)end;function aG:SetDirty(aH)local aF=self.Entities[aH]if aF==nil then return end;local aL=self.Archetypes[aF.Archetype].Chunks[aF.Chunk]self.World.Version=self.World.Version+1;aL.Version=self.World.Version end;function aG:GetData(aH)local aF=self.Entities[aH]if aF==nil then return nil end;local aL=self.Archetypes[aF.Archetype].Chunks[aF.Chunk]return aL:Get(aF.ChunkIndex)end;function aG:SetData(aH,aa,a5)local aF=self.Entities[aH]if aF==nil then return end;local aL=self.Archetypes[aF.Archetype].Chunks[aF.Chunk]aL:Set(aF.ChunkIndex,aa,a5)end;function aG:GetEntityChunk(aH)local aF=self.Entities[aH]if aF==nil then return end;return self.Archetypes[aF.Archetype].Chunks[aF.Chunk],aF.ChunkIndex end;function aG:FilterChunks(aP)local aQ={}for aI,aK in pairs(self.Archetypes)do if aP(a6[aI].Components)then for ag,aL in pairs(aK.Chunks)do table.insert(aQ,aL)end end end;return aQ end;local aR={}local aS={}local aT={'task','render','process','processIn','processOut','transform'}local function aU(m)if m==nil then error('System configuration is required for its creation')end;if m.Name==nil then error('The system "Name" is required for registration')end;if aS[m.Name]~=nil then error('Another System already registered with that name')end;if m.Step==nil then m.Step='transform'end;if not table.find(aT,m.Step)then error('The "step" parameter must one of ',table.concat(aT,', '))end;if m.Step=='task'then if m.Order~=nil then error('Task-type systems do not accept the "Order" parameter')end;if m.ShouldUpdate~=nil then error('Task-type systems do not accept the "ShouldUpdate" parameter')end;if m.BeforeUpdate~=nil then error('Task-type systems do not accept the "BeforeUpdate" parameter')end;if m.Update~=nil then error('Task-type systems do not accept the "Update" parameter')end;if m.AfterUpdate~=nil then error('Task-type systems do not accept the "AfterUpdate" parameter')end;if m.OnEnter~=nil then error('Task-type systems do not accept the "OnEnter" parameter')end;if m.OnExit~=nil then error('Task-type systems do not accept the "OnExit" parameter')end;if m.Execute==nil then error('The task "Execute" method is required for registration')end end;if m.Order==nil or m.Order<0 then m.Order=50 end;table.insert(aR,{Filter=l(m),Name=m.Name,RequireAll=m.RequireAll,RequireAny=m.RequireAny,RequireAllOriginal=m.RequireAllOriginal,RequireAnyOriginal=m.RequireAnyOriginal,RejectAll=m.RejectAll,RejectAny=m.RejectAny,ShouldUpdate=m.ShouldUpdate,BeforeUpdate=m.BeforeUpdate,Update=m.Update,AfterUpdate=m.AfterUpdate,OnCreate=m.OnCreate,OnEnter=m.OnEnter,OnExit=m.OnExit,OnRemove=m.OnRemove,BeforeExecute=m.BeforeExecute,Execute=m.Execute,Step=m.Step,Order=m.Order})local av=table.getn(aR)aS[m.Name]=av;return av end;local aV={}aV.__index=aV;local aW=0.008;local aX=0.002;function aV.New(az,aY)return setmetatable({World=az,EntityManager=aY,min_vruntime=0,rbtree=a3(),LastEntityManagerVersion=-1,Systems={}},aV)end;function aV:AddSystem(aZ,m)if self.Systems[aZ]~=nil then return end;if m==nil then m={}end;local a_={Id=aZ,name=aR[aZ].Name,RequireAll=aR[aZ].RequireAll,RequireAny=aR[aZ].RequireAny,RequireAllOriginal=aR[aZ].RequireAllOriginal,RequireAnyOriginal=aR[aZ].RequireAnyOriginal,RejectAll=aR[aZ].RejectAll,RejectAny=aR[aZ].RejectAny,Filter=aR[aZ].Filter,BeforeExecute=aR[aZ].BeforeExecute,Execute=aR[aZ].Execute,Config=m}self.Systems[aZ]=a_;self.LastEntityManagerVersion=0 end;function aV:Run(b0)if self.EntityManager.Version~=self.LastEntityManagerVersion then self:Update()self.LastEntityManagerVersion=self.EntityManager.Version end;local E=self.rbtree;local az=self.World;local b1=math.max(aW,0.01667-(os.clock()-b0.frameReal)-aX)local b2={}local b3=os.clock()local b4,aL,a_,b5,b6;local b7=X(E)while b7~=nil do Q(E,b7)aL=b7.data[1]a_=b7.data[2]b5=b7.data[3]b6=b7.data[4]b4=os.clock()if b6==0 then b6=b4 end;local b8=a_.RequireAllOriginal;if b8==nil then b8=a_.RequireAnyOriginal end;local b9=table.getn(b8)local ba=a_.Execute;az.Version=az.Version+1;if a_.BeforeExecute~=nil then a_.BeforeExecute(b0,az,a_)end;local bb=aL.Version==0 or aL.Version>b5;local aB=aL.buffers;local bc=aB[aw]local bd=table.create(b9)local be=false;for bf,bg in ipairs(b8)do if aB[bg]~=nil then bd[bf]=aB[bg]else bd[bf]={}end end;local bh={process=b0.process,frame=b0.frame,frameReal=b0.frameReal,delta=b0.delta,deltaExec=b4-b6}for aD=1,aL.Count do if ba(bh,az,bb,bc[aD],aD,table.unpack(bd))then be=true end end;if be then aL.Version=az.Version end;b7.data[3]=az.Version;b7.data[4]=b4;b7.key=b7.key+os.clock()-b4;O(E,b7)if os.clock()-b3>b1 then break end;b7=M(b7)end;local bi=X(E)if bi~=nil then self.min_vruntime=math.max(bi.key-b,0)else self.min_vruntime=0 end end;function aV:Update()local E=self.rbtree;local bj=self.Systems;local aY=self.EntityManager;local bk=self.min_vruntime;local bl=self.World.Version;local bm={}local bn={}local aL,a_;a0(E,function(b7)aL=b7.data[1]a_=b7.data[2]if bm[aL]==nil then bm[aL]={}end;if bm[aL][a_]==nil then bm[aL][a_]={}end;table.insert(bm[aL][a_],b7)bn[aL]=true end)for ag,bo in pairs(bj)do local aQ=aY:FilterChunks(bo.Filter.Match)for bp,bq in pairs(aQ)do bn[bq]=nil;if bm[bq]==nil then O(E,a4(bk,{bq,bo,bl,0}))elseif bm[bq][bo]==nil then O(E,a4(bk,{bq,bo,bl,0}))end end end;for br,g in pairs(bn)do for bs,b2 in pairs(bm[br])do for g,b7 in ipairs(b2)do Q(E,b7)end end end end;local function bt(az,bj)local bu={processIn={},process={},processOut={},transform={},render={}}local bv={processIn={},process={},processOut={},transform={},render={}}local bw={}local bx={}for aE,a_ in pairs(bj)do if a_.Update~=nil then if bu[a_.Step][a_.Order]==nil then bu[a_.Step][a_.Order]={}table.insert(bv[a_.Step],a_.Order)end;table.insert(bu[a_.Step][a_.Order],a_)end;if a_.OnEnter~=nil or a_.OnExit~=nil then table.insert(bw,a_)end;if a_.OnRemove~=nil then table.insert(bx,a_)end end;for g,by in pairs(bv)do table.sort(by)end;local bz=function(bA,aY,b0,bB)local bC=bu[bA]for ag,by in pairs(bv[bA])do for bp,a_ in pairs(bC[by])do if a_.ShouldUpdate==nil or a_.ShouldUpdate(b0,bB,az,a_)then a_.lastUpdate=b0;local b8=a_.RequireAllOriginal;if b8==nil then b8=a_.RequireAnyOriginal end;local b9=table.getn(b8)local bD=a_.Version;local aQ=aY:FilterChunks(a_.Filter.Match)local bE=a_.Update;az.Version=az.Version+1;if a_.BeforeUpdate~=nil then a_.BeforeUpdate(b0,bB,az,a_)end;for aE,aL in pairs(aQ)do local bb=aL.Version==0 or aL.Version>bD;local aB=aL.Buffers;local bc=aB[aw]local bd=table.create(b9)local be=false;for bf,bg in ipairs(b8)do if aB[bg]~=nil then bd[bf]=aB[bg]else bd[bf]={}end end;for aD=1,aL.Count do if bE(b0,az,bb,bc[aD],aD,table.unpack(bd))then be=true end end;if be then aL.Version=az.Version end end;if a_.AfterUpdate~=nil then a_.AfterUpdate(b0,bB,az,a_)end;a_.Version=az.Version end end end end;local bF=function(bG,aY,b0)az.Version=az.Version+1;for aH,bH in pairs(bG)do local aL,aD=aY:GetEntityChunk(aH)if aL~=nil then local aB=aL.Buffers;local bI=aL.Archetype;local bJ=bI:WithAll(bH.Lost):WithoutAll(bH.Received)for bp,a_ in pairs(bw)do local bK=a_.Filter.Match(bI.Components)local bL=a_.Filter.Match(bJ.Components)local bM=nil;if a_.OnEnter~=nil and bK and not bL then bM=a_.OnEnter elseif a_.OnExit~=nil and bL and not bK then bM=a_.OnExit end;if bM~=nil then local b8=a_.RequireAllOriginal;if b8==nil then b8=a_.RequireAnyOriginal end;local bd=table.create(table.getn(b8))for bf,bg in ipairs(b8)do if aB[bg]~=nil then bd[bf]=aB[bg]else bd[bf]={}end end;if bM(b0,az,aH,aD,table.unpack(bd))then aL.Version=az.Version end end end end end end;local bN=function(bO,aY,b0)az.Version=az.Version+1;for aH,g in pairs(bO)do local aL,aD=aY:GetEntityChunk(aH)if aL~=nil then local aB=aL.Buffers;for g,a_ in pairs(bx)do if a_.Filter.Match(aL.Archetype.Components)then local b8=a_.RequireAllOriginal;if b8==nil then b8=a_.RequireAnyOriginal end;local bd=table.create(table.getn(b8))for bf,bg in ipairs(b8)do if aB[bg]~=nil then bd[bf]=aB[bg]else bd[bf]={}end end;if a_.OnRemove(b0,az,aH,aD,table.unpack(bd))then aL.Version=az.Version end end end end end end;return bz,bF,bN end;local function bP(bj,m)if m==nil then m={}end;local bQ=1;local bR={}local bS;local bT,bU,bV;local bW;local bB=1;local bX=nil;local bY=0;local bZ=0;local b_=0;local c0=0;local c1=0;local c2=0;local c3=10;local c4=0;local aY;local c5;local c6;local c7={}local c8={}local c9={}local ca={}local az;local cb=false;local function cc()local av=bQ;bQ=bQ+1;c5:Set(av,ah)c7[av]=true;ca[av]=ah;cb=true;return av end;local function cd(aF,aa)if c7[aF]==true then return c5:GetValue(aF,aa)elseif c9[aF]~=nil then return c6:GetValue(aF,aa)else return aY:GetValue(aF,aa)end end;local function ce(aF)if c7[aF]==true then c5:SetDirty(aF)else if c9[aF]~=nil then c6:SetDirty(aF)end;aY:SetDirty(aF)end end;local function cf(aF,aa,...)local aA=ca[aF]if aA==nil then return end;cb=true;local cg=aA:With(aa)local ch=aA~=cg;if ch then ca[aF]=cg end;local ao;local ci={...}if ci and ci[1]and typeof(ci[1])=='table'and ci[1].__v then ao=ci[1].__v[0]else ao=aj[aa](table.unpack(ci))end;if c7[aF]==true then if ch then c5:Set(aF,cg)end;c5:SetValue(aF,aa,ao)else if ch then if c9[aF]==nil then c9[aF]={received={},lost={}}c6:Set(aF,cg)c6:SetData(aF,aY:GetData(aF))else c6:Set(aF,cg)end end;if c9[aF]~=nil then c6:SetValue(aF,aa,ao)local cj=false;for aE,h in pairs(c9[aF].lost)do if h==aa then table.remove(c9[aF].lost,aE)cj=true;break end end;if not cj then table.insert(c9[aF].received,aa)end end;aY:SetValue(aF,aa,ao)end end;local function ck(aF,aa,cl,...)local bM=ak[aa][cl]if not bM then return nil end;local cm,ao=bM(az.Get(aF,aa),table.unpack({...}))if cm then az.Set(aF,aa,{__v={ao}})end;return ao end;local function cn(aF,aa)local aA=ca[aF]if aA==nil then return end;if c8[aF]==true then return end;cb=true;if aa==nil then if c7[aF]==true then c5:Remove(aF)c7[aF]=nil;ca[aF]=nil else if c8[aF]==nil then c8[aF]=true end end else local cg=aA:Without(aa)local ch=aA~=cg;if ch then ca[aF]=cg end;if c7[aF]==true then if ch then c5:Set(aF,cg)end else if ch then if c9[aF]==nil then c9[aF]={received={},lost={}}c6:Set(aF,cg)c6:SetData(aF,aY:GetData(aF))else c6:Set(aF,cg)end end;if c9[aF]~=nil then c6:SetValue(aF,aa,nil)local cj=false;for aE,h in pairs(c9[aF].received)do if h==aa then table.remove(c9[aF].received,aE)cj=true;break end end;if not cj then table.insert(c9[aF].lost,aa)end end;aY:SetValue(aF,aa,nil)end end end;local function co(aF,aa)if ca[aF]==nil then return false end;return ca[aF]:Has(aa)end;local function cp(cq,a1)local cr=false;local cs=function()cr=true end;local aQ=aY:FilterChunks(cq.Match)for aE,aL in pairs(aQ)do local aB=aL.Buffers;local bd=table.create(table.getn(cq.Components))for bf,bg in ipairs(cq.Components)do if aB[bg]~=nil then bd[bf]=aB[bg]else bd[bf]={}end end;local bc=aB[aw]local be=false;for aD=1,aL.Count do if a1(cs,bc[aD],aD,table.unpack(bd))then be=true end;if cr then break end end;if be then aL.Version=az.Version end;if cr then break end end end;local function ct(aZ,by,m)if aZ==nil then return end;if aR[aZ]==nil then error('There is no registered system with the given ID')end;if aR[aZ].Step=='task'then bS:AddSystem(aZ)else if bR[aZ]~=nil then return end;if aY:Count()>0 or c5:Count()>0 then error('Adding systems is not allowed after adding entities in the world')end;if m==nil then m={}end;local a_={Id=aZ,Name=aR[aZ].Name,RequireAll=aR[aZ].RequireAll,RequireAny=aR[aZ].RequireAny,RequireAllOriginal=aR[aZ].RequireAllOriginal,RequireAnyOriginal=aR[aZ].RequireAnyOriginal,RejectAll=aR[aZ].RejectAll,RejectAny=aR[aZ].RejectAny,Filter=aR[aZ].Filter,OnCreate=aR[aZ].OnCreate,ShouldUpdate=aR[aZ].ShouldUpdate,BeforeUpdate=aR[aZ].BeforeUpdate,Update=aR[aZ].Update,AfterUpdate=aR[aZ].AfterUpdate,OnEnter=aR[aZ].OnEnter,OnExit=aR[aZ].OnExit,OnRemove=aR[aZ].OnRemove,Step=aR[aZ].Step,Order=aR[aZ].Order,Version=0,LastUpdate=c0,Config=m}if by~=nil and by<0 then a_.Order=50 end;bR[aZ]=a_;c4=0;if a_.OnCreate~=nil then a_.OnCreate(az,a_)end end end;local function cu(aF)if ca[aF]==nil then return false end;if c7[aF]==true then return false end;if c8[aF]==true then return false end;return true end;local function cv()if az._steppedConn~=nil then az._steppedConn:Disconnect()az._steppedConn=nil end;if az._heartbeatConn~=nil then az._heartbeatConn:Disconnect()az._heartbeatConn=nil end;if az._renderSteppedConn~=nil then az._renderSteppedConn:Disconnect()az._renderSteppedConn=nil end;aY=nil;c5=nil;c6=nil;c9=nil;c8=nil;bR=nil;bT=nil;bU=nil;bV=nil;ca=nil;bS=nil;az.Create=nil;az.Set=nil;az.Dirty=nil;az.Get=nil;az.Remove=nil;az.Has=nil;az.ForEach=nil;az.AddSystem=nil;az.Alive=nil;az.Update=nil;az.Destroy=nil;az=nil end;local function cw(b0)if not cb then return end;cb=false;local cx=false;local bG={}bV(c8,aY,b0)for aH,cy in pairs(c8)do aY:Remove(aH)ca[aH]=nil;if c9[aH]~=nil then c9[aH]=nil;c6:Remove(aH)end end;c8={}for aH,cz in pairs(c9)do aY:Set(aH,ca[aH])aY:SetData(aH,c6:GetData(aH))c6:Remove(aH)if table.getn(cz.received)>0 or table.getn(cz.lost)>0 then if bG[aH]==nil then bG[aH]={Received={},Lost={}}end;if table.getn(cz.received)>0 then for g,aa in ipairs(cz.received)do table.insert(bG[aH].Received,aa)end end;if table.getn(cz.lost)>0 then for g,aa in ipairs(cz.lost)do table.insert(bG[aH].Lost,aa)end end;cx=true end end;c9={}for aH,cy in pairs(c7)do aY:Set(aH,ca[aH])aY:SetData(aH,c5:GetData(aH))c5:Remove(aH)if bG[aH]==nil then bG[aH]={Received={},Lost={}}end;for g,aa in ipairs(ca[aH].Components)do table.insert(bG[aH].Received,aa)end;cx=true end;c7={}if cx then bU(bG,aY,b0)bG=nil end end;local function cA(cB)m.Frequency=cB;if m.Frequency==nil then m.Frequency=30 end;local cC=math.round(math.abs(m.Frequency)/2)*2;if cC<2 then cC=2 end;if m.Frequency~=cC then m.Frequency=cC;print(string.format(">>> ATTENTION! The execution frequency of world has been changed to %d <<<",cC))end;bW=1000/m.Frequency/1000;az.Frequency=m.Frequency end;local function cD(bA,cE)if not a:IsRunning()then return end;if bX==nil then bX=cE end;local cF=cE;cE=cE-bX;if c4<a7 then bT,bU,bV=bt(az,bR)c4=a7 end;if bA~='process'then if c0~=c1 then bB=1+(cE-c0)/bW else bB=1 end;if bA=='processIn'then bZ=cE;b_=cF;if bY==0 then bY=bZ end;if c0==0 then c0=bZ;c1=bZ end;c2=bZ-bY;bB=1 elseif bA=='render'then bY=bZ end;local b0={process=c0,frame=bZ,frameReal=b_,now=cE,nowReal=cF,delta=c2}bT(bA,aY,b0,bB)while cb do cw(b0)end;if bA=='transform'then bS:Run(b0)cw(b0)end else local cG=c0;local cH=0;local cz=false;while c0<bZ and cH<c3 do cz=true;if c4<a7 then bT,bU,bV=bt(az,bR)c4=a7 end;local b0={process=c0,processDelta=bW,frame=bZ,frameReal=b_,now=cE,nowReal=cF,delta=c2}bT(bA,aY,b0,1)while cb do cw(b0)end;cH=cH+1;c0=c0+bW end;if cz then c1=cG end end end;az={Version=0,Frequency=m.Frequency,Create=cc,Get=cd,Set=cf,Dirty=ce,Call=ck,Remove=cn,Has=co,ForEach=cp,AddSystem=ct,Alive=cu,Destroy=cv,Update=cD,SetFrequency=cA}cA(m.Frequency)aY=aG.New(az)c5=aG.New(az)c6=aG.New(az)bS=aV.New(az,aY)if bj~=nil then for ag,a_ in pairs(bj)do ct(a_)end end;if not m.DisableAutoUpdate then az._steppedConn=a.Stepped:Connect(function()cD('processIn',os.clock())cD('process',os.clock())cD('processOut',os.clock())end)az._heartbeatConn=a.Heartbeat:Connect(function()cD('transform',os.clock())end)if not a:IsServer()then az._renderSteppedConn=a.RenderStepped:Connect(function()cD('render',os.clock())end)end end;return az end;return{RegisterComponent=aq,RegisterSystem=aU,Filter=l,CreateWorld=bP}
